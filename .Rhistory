ylab("Time until first steering correction (s)")
ggplot(negative_offset, aes(as.factor(heading), FirstSteeringTime)) +
geom_boxplot() +
ggtitle("First steering time across heading angles: boxplots") +
xlab("Heading angle (degrees)") +
ylab("Time until first steering correction (s)")
library(ggplot2)
library(dplyr)
negative_offset <- workingdatafinal %>%
filter(heading <= 0, FirstSteeringTime < 1 & FirstSteeringTime > 0 & FirstSteeringTime > 0.2)
# creates dataframe with only positive angle offsets and removes trials where SWA was already above threshold at the start of the time
# input FirstSteeringTime < 1 & FirstSteeringTime > 0 & FirstSteeringTime > 0.2 to remove outliers
ggplot(negative_offset, aes(x = heading, y = FirstSteeringTime)) +
geom_jitter() +
geom_smooth() +
ggtitle("First steering time across heading angles") +
xlab("Heading angle (degrees)") +
ylab("Time until first steering correction (s)")
ggplot(negative_offset, aes(as.factor(heading), FirstSteeringTime)) +
geom_boxplot() +
ggtitle("First steering time across heading angles: boxplots") +
xlab("Heading angle (degrees)") +
ylab("Time until first steering correction (s)")
library(dplyr)
# calculating mean and median first steering timings for eaching heading offset
# negative offset
negative_offset %>%
group_by(heading) %>%
summarise(meanFirstSteering = mean(FirstSteeringTime, na.rm = TRUE))
negative_offset %>%
group_by(heading) %>%
summarise(medianFirstSteering = median(FirstSteeringTime, na.rm = TRUE))
# positive offset
positive_offset %>%
group_by(heading) %>%
summarise(meanFirstSteering = mean(FirstSteeringTime, na.rm = TRUE))
positive_offset %>%
group_by(heading) %>%
summarise(medianFirstSteering = median(FirstSteeringTime, na.rm = TRUE))
library(ggplot2)
library(dplyr)
negative_offset <- workingdatafinal %>%
filter(heading <= 0, FirstSteeringTime < 1 & FirstSteeringTime > 0 & FirstSteeringTime > 0.2)
# creates dataframe with only positive angle offsets and removes trials where SWA was already above threshold at the start of the time
# input FirstSteeringTime < 1 & FirstSteeringTime > 0 & FirstSteeringTime > 0.2 to remove outliers
ggplot(negative_offset, aes(x = heading, y = FirstSteeringTime)) +
geom_jitter() +
geom_smooth() +
ggtitle("First steering time across heading angles") +
xlab("Heading angle (degrees)") +
ylab("Time until first steering correction (s)")
ggplot(negative_offset, aes(as.factor(heading), FirstSteeringTime)) +
geom_boxplot() +
ggtitle("First steering time across heading angles: boxplots") +
xlab("Heading angle (degrees)") +
ylab("Time until first steering correction (s)")
library(ggplot2)
library(dplyr)
positive_offset <- workingdatafinal %>%
filter(heading >= 0, FirstSteeringTime > 0.2 & FirstSteeringTime < 1.6) # creates dataframe with only positive angle offsets and removes trials where SWA was already above threshold at the start of the time
# input FirstSteeringTime > 0.2 & FirstSteeringTime < 1.6 to remove outliers
ggplot(positive_offset, aes(x = heading, y = FirstSteeringTime)) +
geom_jitter() +
geom_smooth() +
ggtitle("First steering time across heading angles") +
xlab("Heading angle (degrees)") +
ylab("Time until first steering correction (s)")
ggplot(positive_offset, aes(as.factor(heading), FirstSteeringTime)) +
geom_boxplot() +
ggtitle("First steering time across heading angles: boxplots") +
xlab("Heading angle (degrees)") +
ylab("Time until first steering correction (s)")
library(ggplot2)
library(dplyr)
positive_offset <- workingdatafinal %>%
filter(heading >= 0, FirstSteeringTime > 0) # creates dataframe with only positive angle offsets and removes trials where SWA was already above threshold at the start of the time
# input FirstSteeringTime > 0.2 & FirstSteeringTime < 1.6 to remove outliers
ggplot(positive_offset, aes(x = heading, y = FirstSteeringTime)) +
geom_jitter() +
geom_smooth() +
ggtitle("First steering time across heading angles") +
xlab("Heading angle (degrees)") +
ylab("Time until first steering correction (s)")
ggplot(positive_offset, aes(as.factor(heading), FirstSteeringTime)) +
geom_boxplot() +
ggtitle("First steering time across heading angles: boxplots") +
xlab("Heading angle (degrees)") +
ylab("Time until first steering correction (s)")
library(ggplot2)
library(dplyr)
negative_offset <- workingdatafinal %>%
filter(heading <= 0, FirstSteeringTime > 0)
# creates dataframe with only positive angle offsets and removes trials where SWA was already above threshold at the start of the time
# input FirstSteeringTime < 1 & FirstSteeringTime > 0 & FirstSteeringTime > 0.2 to remove outliers
ggplot(negative_offset, aes(x = heading, y = FirstSteeringTime)) +
geom_jitter() +
geom_smooth() +
ggtitle("First steering time across heading angles") +
xlab("Heading angle (degrees)") +
ylab("Time until first steering correction (s)")
ggplot(negative_offset, aes(as.factor(heading), FirstSteeringTime)) +
geom_boxplot() +
ggtitle("First steering time across heading angles: boxplots") +
xlab("Heading angle (degrees)") +
ylab("Time until first steering correction (s)")
library(dplyr)
# calculating mean and median first steering timings for eaching heading offset
# negative offset
negative_offset %>%
group_by(heading) %>%
summarise(meanFirstSteering = mean(FirstSteeringTime, na.rm = TRUE))
negative_offset %>%
group_by(heading) %>%
summarise(medianFirstSteering = median(FirstSteeringTime, na.rm = TRUE))
# positive offset
positive_offset %>%
group_by(heading) %>%
summarise(meanFirstSteering = mean(FirstSteeringTime, na.rm = TRUE))
positive_offset %>%
group_by(heading) %>%
summarise(medianFirstSteering = median(FirstSteeringTime, na.rm = TRUE))
library(ggplot2)
library(dplyr)
positive_offset <- workingdatafinal %>%
filter(heading >= 0, FirstSteeringTime > 0) # creates dataframe with only positive angle offsets and removes trials where SWA was already above threshold at the start of the time
# input FirstSteeringTime > 0.2 & FirstSteeringTime < 1.6 to remove outliers
ggplot(positive_offset, aes(x = heading, y = FirstSteeringTime)) +
geom_jitter() +
geom_smooth() +
ggtitle("First steering time across heading angles") +
xlab("Heading angle (degrees)") +
ylab("Time until first steering correction (s)")
ggplot(positive_offset, aes(as.factor(heading), FirstSteeringTime)) +
geom_boxplot() +
ggtitle("First steering time across heading angles: boxplots") +
xlab("Heading angle (degrees)") +
ylab("Time until first steering correction (s)")
library(ggplot2)
library(dplyr)
negative_offset <- workingdatafinal %>%
filter(heading <= 0, FirstSteeringTime > 0)
# creates dataframe with only positive angle offsets and removes trials where SWA was already above threshold at the start of the time
# input FirstSteeringTime < 1 & FirstSteeringTime > 0 & FirstSteeringTime > 0.2 to remove outliers
ggplot(negative_offset, aes(x = heading, y = FirstSteeringTime)) +
geom_jitter() +
geom_smooth() +
ggtitle("First steering time across heading angles") +
xlab("Heading angle (degrees)") +
ylab("Time until first steering correction (s)")
ggplot(negative_offset, aes(as.factor(heading), FirstSteeringTime)) +
geom_boxplot() +
ggtitle("First steering time across heading angles: boxplots") +
xlab("Heading angle (degrees)") +
ylab("Time until first steering correction (s)")
library(dplyr)
# calculating mean and median first steering timings for eaching heading offset
# negative offset
negative_offset %>%
group_by(heading) %>%
summarise(meanFirstSteering = mean(FirstSteeringTime, na.rm = TRUE))
negative_offset %>%
group_by(heading) %>%
summarise(medianFirstSteering = median(FirstSteeringTime, na.rm = TRUE))
# positive offset
positive_offset %>%
group_by(heading) %>%
summarise(meanFirstSteering = mean(FirstSteeringTime, na.rm = TRUE))
positive_offset %>%
group_by(heading) %>%
summarise(medianFirstSteering = median(FirstSteeringTime, na.rm = TRUE))
TimeStep(heading_angle = 5, samples = 5, timestep = 1, speed = 10, SimutlationTime = 30)
knitr::opts_chunk$set(echo = TRUE)
#### Initial State - starting position, heading angle, time step
TimeStep <- function(heading_angle, samples, timestep, speed, SimutlationTime){
startpos_x <- 0
startpos_y <- 0
heading_angle <- 5 # degrees of the heading offset
heading_angle <- heading_angle * pi /180 # converting to degrees
samples <- 5 # per second
timestep <- 1 / samples
speed <- 10 # in metres per second
SimulationTime <- 30 # in seconds
TotalSamples <- SimulationTime * samples # number of samples allowed within the simulation time
X <- numeric(TotalSamples) # x the rows length of number of samples
Y <- numeric(TotalSamples) # y the rows length of number of samples
#### Update loop
for (i in 1:TotalSamples) { # for index in length of total samples
if (i > 1) { # if the index is more than 1
X[i] = X[i-1] + # the index of the x vector of zeros is equal to the index minus 1 plus
cos(heading_angle) * speed * timestep # the cosine of the heading angle mulitpled by speed multiplied by the timestep
Y[i] = Y[i-1] + # the index of the y vector of zeros is equal to the index minus 1 plus
sin(heading_angle) * speed * timestep # the sine of the heading angle mulitpled by speed multiplied by the timestep
}
}
#### plotting
result <- plot(X, Y)
### Dataframe and saving
x_y_coordinates <- data.frame(X, Y) # saving x and y coords in dataframe
View(x_y_coordinates) # view the new dataframe
write.csv(x_y_coordinates, file = "myTimeSteppingExampleDataR.csv") # writes dataframe to .csv file
return(result)
}
TimeStep(heading_angle = 5, samples = 5, timestep = 1, speed = 10, SimutlationTime = 30)
TimeStep(heading_angle = 10, samples = 5, timestep = 1, speed = 10, SimutlationTime = 30)
#### Initial State - starting position, heading angle, time step
TimeStep <- function(heading_angle, samples, timestep, speed, SimutlationTime){
startpos_x <- 0
startpos_y <- 0
heading_angle <- 5 # degrees of the heading offset
heading_angle <- heading_angle * pi /180 # converting to degrees
samples <- 5 # per second
timestep <- 1 / samples
speed <- 10 # in metres per second
SimulationTime <- 30 # in seconds
TotalSamples <- SimulationTime * samples # number of samples allowed within the simulation time
X <- numeric(TotalSamples) # x the rows length of number of samples
Y <- numeric(TotalSamples) # y the rows length of number of samples
#### Update loop
for (i in 1:TotalSamples) { # for index in length of total samples
if (i > 1) { # if the index is more than 1
X[i] = X[i-1] + # the index of the x vector of zeros is equal to the index minus 1 plus
cos(heading_angle) * speed * timestep # the cosine of the heading angle mulitpled by speed multiplied by the timestep
Y[i] = Y[i-1] + # the index of the y vector of zeros is equal to the index minus 1 plus
sin(heading_angle) * speed * timestep # the sine of the heading angle mulitpled by speed multiplied by the timestep
}
}
#### plotting
plot(X, Y)
### Dataframe and saving
x_y_coordinates <- data.frame(X, Y) # saving x and y coords in dataframe
View(x_y_coordinates) # view the new dataframe
write.csv(x_y_coordinates, file = "myTimeSteppingExampleDataR.csv") # writes dataframe to .csv file
return(x_y_coordinates)
}
TimeStep(heading_angle = 10, samples = 10, timestep = 1, speed = 30, SimutlationTime = 30)
#### Initial State - starting position, heading angle, time step
TimeStep <- function(heading_angle, samples, timestep, speed, SimutlationTime){
startpos_x <- 0
startpos_y <- 0
heading_angle <- # 5 # degrees of the heading offset
heading_angle <- heading_angle * pi /180 # converting to degrees
samples <- # 5 # per second
timestep <- timestep / samples # 1 / samples
speed <- # 10 # in metres per second
SimulationTime <- # 30 # in seconds
TotalSamples <- SimulationTime * samples # number of samples allowed within the simulation time
X <- numeric(TotalSamples) # x the rows length of number of samples
Y <- numeric(TotalSamples) # y the rows length of number of samples
#### Update loop
for (i in 1:TotalSamples) { # for index in length of total samples
if (i > 1) { # if the index is more than 1
X[i] = X[i-1] + # the index of the x vector of zeros is equal to the index minus 1 plus
cos(heading_angle) * speed * timestep # the cosine of the heading angle mulitpled by speed multiplied by the timestep
Y[i] = Y[i-1] + # the index of the y vector of zeros is equal to the index minus 1 plus
sin(heading_angle) * speed * timestep # the sine of the heading angle mulitpled by speed multiplied by the timestep
}
}
#### plotting
plot(X, Y)
### Dataframe and saving
x_y_coordinates <- data.frame(X, Y) # saving x and y coords in dataframe
View(x_y_coordinates) # view the new dataframe
write.csv(x_y_coordinates, file = "myTimeSteppingExampleDataR.csv") # writes dataframe to .csv file
return(x_y_coordinates)
}
TimeStep(heading_angle = 10, samples = 10, timestep = 1, speed = 30, SimutlationTime = 30)
TimeStep(heading_angle = 10, samples = 10, timestep = 1, speed = 30, SimulationTime = 30)
#### Initial State - starting position, heading angle, time step
TimeStep <- function(heading_angle, samples, timestep, speed, SimutlationTime){
startpos_x <- 0
startpos_y <- 0
heading_angle <- # 5 # degrees of the heading offset
heading_angle <- heading_angle * pi /180 # converting to degrees
samples <- # 5 # per second
timestep <- timestep / samples # 1 / samples
speed <- # 10 # in metres per second
SimulationTime <- # 30 # in seconds
TotalSamples <- SimulationTime * samples # number of samples allowed within the simulation time
X <- numeric(TotalSamples) # x the rows length of number of samples
Y <- numeric(TotalSamples) # y the rows length of number of samples
#### Update loop
for (i in 1:TotalSamples) { # for index in length of total samples
if (i > 1) { # if the index is more than 1
X[i] = X[i-1] + # the index of the x vector of zeros is equal to the index minus 1 plus
cos(heading_angle) * speed * timestep # the cosine of the heading angle mulitpled by speed multiplied by the timestep
Y[i] = Y[i-1] + # the index of the y vector of zeros is equal to the index minus 1 plus
sin(heading_angle) * speed * timestep # the sine of the heading angle mulitpled by speed multiplied by the timestep
}
}
#### plotting
plot(X, Y)
### Dataframe and saving
x_y_coordinates <- data.frame(X, Y) # saving x and y coords in dataframe
View(x_y_coordinates) # view the new dataframe
write.csv(x_y_coordinates, file = "myTimeSteppingExampleDataR.csv") # writes dataframe to .csv file
return(x_y_coordinates)
}
TimeStep(heading_angle = 10, samples = 10, timestep = 1, speed = 30, SimulationTime = 30)
TimeStep(heading_angle = 10, samples = 10, timestep = 1, speed = 30)
TimeStep(heading_angle = 10, samples = 10, timestep = 1, speed = 30, SimulationTime = 10)
#### Initial State - starting position, heading angle, time step
TimeStep <- function(heading_angle, samples, timestep, speed){
startpos_x <- 0
startpos_y <- 0
heading_angle <- # 5 # degrees of the heading offset
heading_angle <- heading_angle * pi /180 # converting to degrees
samples <- # 5 # per second
timestep <- timestep / samples # 1 / samples
speed <- # 10 # in metres per second
SimulationTime <- 30 # in seconds
TotalSamples <- SimulationTime * samples # number of samples allowed within the simulation time
X <- numeric(TotalSamples) # x the rows length of number of samples
Y <- numeric(TotalSamples) # y the rows length of number of samples
#### Update loop
for (i in 1:TotalSamples) { # for index in length of total samples
if (i > 1) { # if the index is more than 1
X[i] = X[i-1] + # the index of the x vector of zeros is equal to the index minus 1 plus
cos(heading_angle) * speed * timestep # the cosine of the heading angle mulitpled by speed multiplied by the timestep
Y[i] = Y[i-1] + # the index of the y vector of zeros is equal to the index minus 1 plus
sin(heading_angle) * speed * timestep # the sine of the heading angle mulitpled by speed multiplied by the timestep
}
}
#### plotting
plot(X, Y)
### Dataframe and saving
x_y_coordinates <- data.frame(X, Y) # saving x and y coords in dataframe
View(x_y_coordinates) # view the new dataframe
write.csv(x_y_coordinates, file = "myTimeSteppingExampleDataR.csv") # writes dataframe to .csv file
return(x_y_coordinates)
}
TimeStep <- function(heading_angle = 10, samples = 2, timestep = 5, speed = 30)
s
a
a
a
a
TimeStep(heading_angle = 10, samples = 2, timestep = 5, speed = 30)
TimeStep(10, 2, 5, 30)
#### Initial State - starting position, heading angle, time step
TimeStep <- function(heading_angle, samples, timestep, speed){
startpos_x <- 0
startpos_y <- 0
heading_angle <- heading_angle # 5 # degrees of the heading offset
heading_angle <- heading_angle * pi /180 # converting to degrees
samples <- samples # 5 # per second
timestep <- timestep / samples # 1 / samples
speed <- # 10 # in metres per second
SimulationTime <- 30 # in seconds
TotalSamples <- SimulationTime * samples # number of samples allowed within the simulation time
X <- numeric(TotalSamples) # x the rows length of number of samples
Y <- numeric(TotalSamples) # y the rows length of number of samples
#### Update loop
for (i in 1:TotalSamples) { # for index in length of total samples
if (i > 1) { # if the index is more than 1
X[i] = X[i-1] + # the index of the x vector of zeros is equal to the index minus 1 plus
cos(heading_angle) * speed * timestep # the cosine of the heading angle mulitpled by speed multiplied by the timestep
Y[i] = Y[i-1] + # the index of the y vector of zeros is equal to the index minus 1 plus
sin(heading_angle) * speed * timestep # the sine of the heading angle mulitpled by speed multiplied by the timestep
}
}
#### plotting
plot(X, Y)
### Dataframe and saving
x_y_coordinates <- data.frame(X, Y) # saving x and y coords in dataframe
View(x_y_coordinates) # view the new dataframe
write.csv(x_y_coordinates, file = "myTimeSteppingExampleDataR.csv") # writes dataframe to .csv file
return(x_y_coordinates)
}
#### Initial State - starting position, heading angle, time step
TimeStep <- function(heading_angle, samples, timestep, speed){
startpos_x <- 0
startpos_y <- 0
heading_angle <- heading_angle # 5 # degrees of the heading offset
heading_angle <- heading_angle * pi /180 # converting to degrees
samples <- samples # 5 # per second
timestep <- timestep / samples # 1 / samples
speed <- speed # 10 # in metres per second
SimulationTime <- 30 # in seconds
TotalSamples <- SimulationTime * samples # number of samples allowed within the simulation time
X <- numeric(TotalSamples) # x the rows length of number of samples
Y <- numeric(TotalSamples) # y the rows length of number of samples
#### Update loop
for (i in 1:TotalSamples) { # for index in length of total samples
if (i > 1) { # if the index is more than 1
X[i] = X[i-1] + # the index of the x vector of zeros is equal to the index minus 1 plus
cos(heading_angle) * speed * timestep # the cosine of the heading angle mulitpled by speed multiplied by the timestep
Y[i] = Y[i-1] + # the index of the y vector of zeros is equal to the index minus 1 plus
sin(heading_angle) * speed * timestep # the sine of the heading angle mulitpled by speed multiplied by the timestep
}
}
#### plotting
plot(X, Y)
### Dataframe and saving
x_y_coordinates <- data.frame(X, Y) # saving x and y coords in dataframe
View(x_y_coordinates) # view the new dataframe
write.csv(x_y_coordinates, file = "myTimeSteppingExampleDataR.csv") # writes dataframe to .csv file
return(x_y_coordinates)
}
TimeStep(heading_angle = 15, samples = 10, timestep = 5, speed = 30)
TimeStep(heading_angle = 90, samples = 10, timestep = 5, speed = 30)
TimeStep(heading_angle = 15, samples = 10, timestep = 5, speed = 30, SimulationTime = 10)
#### Initial State - starting position, heading angle, time step
TimeStep <- function(heading_angle, samples, timestep, speed, SimulationTime){
startpos_x <- 0
startpos_y <- 0
heading_angle <- heading_angle # 5 # degrees of the heading offset
heading_angle <- heading_angle * pi /180 # converting to degrees
samples <- samples # 5 # per second
timestep <- timestep / samples # 1 / samples
speed <- speed # 10 # in metres per second
SimulationTime <- SimulationTime # in seconds
TotalSamples <- SimulationTime * samples # number of samples allowed within the simulation time
X <- numeric(TotalSamples) # x the rows length of number of samples
Y <- numeric(TotalSamples) # y the rows length of number of samples
#### Update loop
for (i in 1:TotalSamples) { # for index in length of total samples
if (i > 1) { # if the index is more than 1
X[i] = X[i-1] + # the index of the x vector of zeros is equal to the index minus 1 plus
cos(heading_angle) * speed * timestep # the cosine of the heading angle mulitpled by speed multiplied by the timestep
Y[i] = Y[i-1] + # the index of the y vector of zeros is equal to the index minus 1 plus
sin(heading_angle) * speed * timestep # the sine of the heading angle mulitpled by speed multiplied by the timestep
}
}
#### plotting
plot(X, Y)
### Dataframe and saving
x_y_coordinates <- data.frame(X, Y) # saving x and y coords in dataframe
View(x_y_coordinates) # view the new dataframe
write.csv(x_y_coordinates, file = "myTimeSteppingExampleDataR.csv") # writes dataframe to .csv file
return(x_y_coordinates)
}
TimeStep(heading_angle = 10, samples = 1, timestep = 5, speed = 15, SimulationTime = 60)
knitr::opts_chunk$set(echo = TRUE)
install.packages(ggplot2)
install.packages(dplyr)
# install.packages("magrittr")
setwd("M:/PhD/Project/Experiment_Code/Straights")
mydata = read.csv("BenLui17_2.csv")
mydata %>%
mutate(YawRate_seconds[-length(YawRate_seconds)] - YawRate_seconds[-1])
library(dplyr)
mydata %>%
mutate(yaw_rate_diff = YawRate_seconds[-length(YawRate_seconds)] - YawRate_seconds[-1])
yaw_rate_diff <- mydata$yaw_rate_diff[-length(mydata$yaw_rate_diff)] - mydata$yaw_rate_diff[-1]
View(yaw_rate_diff)
knitr::opts_chunk$set(echo = TRUE)
install.packages(ggplot2)
install.packages(dplyr)
# install.packages("magrittr")
setwd("M:/PhD/Project/Experiment_Code/Straights")
mydata = read.csv("BenLui17_2.csv")
yaw_rate_diff <- mydata$yaw_rate_diff[-length(mydata$yaw_rate_diff)] - mydata$yaw_rate_diff[-1]
example <- mydata$yaw_rate_diff[-length(mydata$yaw_rate_diff)] - mydata$yaw_rate_diff[-1]
knitr::opts_chunk$set(echo = TRUE)
install.packages(ggplot2)
install.packages(dplyr)
# install.packages("magrittr")
setwd("M:/PhD/Project/Experiment_Code/Straights")
mydata = read.csv("BenLui17_2.csv")
View(mydata)
mydata$YawRate_seconds[-length(mydata$YawRate_seconds)] - mydata$YawRate_seconds[-1]
example <- mydata$YawRate_seconds[-length(mydata$YawRate_seconds)] - mydata$YawRate_seconds[-1]
View(example)
x <- rep(0, ncol(example))
example <- rbind(x, example)
x <- rep(0, ncol(example))
x <- rep(0, ncol(example)
)
x <- rep(0, ncol(example))
example_new <- add_row(example, x = 0)
example_new <- add_row(example, y = 0)
add_row(example, x = 4, y = 0)
mydata_new <- mydata %>%
mutate(idx=row_number(YawRate_seconds))
mydata_new <- left_join(mydata_new, mydata_new %>% mutate(idx=idx+1), by='idx')
mydata_new <- mydata_new %>% mutate(lag_diff=a.x-a.y) %>% select(a=a.x, lag_diff)
mydata_new
mydata_new <- mydata_new %>% mutate(lag_diff=YawRate_seconds.x-YawRate_seconds.y) %>% select(YawRate_seconds=YawRate_seconds.x, lag_diff)
View(mydata_new)
# chooseCRANmirror(graphics=FALSE, ind=1)
knitr::opts_chunk$set(echo = TRUE)
install.packages(ggplot2)
install.packages(dplyr)
# install.packages("magrittr")
setwd("M:/PhD/Project/Experiment_Code/Straights") # set working directory
temp = list.files(pattern = "*.csv") # list all CSV files in the directory
myfiles = lapply(temp, read.csv) # read these CSV in the directory
workingdata <- do.call(rbind.data.frame, myfiles) # convert and combine the CSV files into dataframe
workingdata <- mydata %>%
mutate(idx=row_number(YawRate_seconds))
workingdata <- left_join(workingdata, workingdata %>%
mutate(idx=idx+1), by='idx')
workingdata<- mworkingdata %>%
mutate(lag_diff=YawRate_seconds.x-YawRate_seconds.y) %>% select(YawRate_seconds=YawRate_seconds.x, lag_diff)
workingdata <- mydata %>%
mutate(idx=row_number(YawRate_seconds))
workingdata <- left_join(workingdata, workingdata %>%
mutate(idx=idx+1), by='idx')
workingdata<- workingdata %>%
mutate(lag_diff=YawRate_seconds.x-YawRate_seconds.y) %>% select(YawRate_seconds=YawRate_seconds.x, lag_diff)
View(workingdata)
knitr::opts_chunk$set(echo = TRUE)
install.packages(ggplot2)
install.packages(dplyr)
# install.packages("magrittr")
setwd("M:/PhD/Project/Experiment_Code/Straights")
mydata = read.csv("BenLui17_2.csv")
example <- mydata$SWA - c(0,mydata$SWA[-length(mydata$SWA)]
)
View(example)
example <- mydata$YawRate_seconds - c(0,mydata$YawRate_seconds[-length(mydata$YawRate_seconds)])
View(example)
