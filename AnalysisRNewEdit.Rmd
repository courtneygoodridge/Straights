---
title: "AnalysisRAverageThreshold"
output: 
  html_document:
    self_contained: no
---

```{r setup, echo=TRUE}
# chooseCRANmirror(graphics=FALSE, ind=1) # uncomment for knitting
# rm(list = ls()) # clear workspace
knitr::opts_chunk$set(echo = TRUE)
install.packages(ggplot2)
install.packages(dplyr)
install.packages(matlab)
install.packages(zoo)
# install.packages("magrittr")
setwd("M:/PhD/Project/Experiment_Code/Straights") # set working directory
temp = list.files(pattern = "*.csv") # list all CSV files in the directory
myfiles = lapply(temp, read.csv) # read these CSV in the directory
workingdata <- do.call(rbind.data.frame, myfiles) # convert and combine the CSV files into dataframe
```

```{r creating dataframe and yaw rate change variable, echo=TRUE}
library(zoo)
library(dplyr)
library(tidyr)


# change in steering threshold
yawratechange_threshold = 0.10 # higher threshold for the new thresholding technique

YRchange <- workingdata$YawRate_seconds - c(0,workingdata$YawRate_seconds[-length(workingdata$YawRate_seconds)]) # calculating difference in yawrate

YRchange <- data.frame(YRchange) # convert yaw rate to dataframe

colnames(YRchange) <- c("YawRateChange") # change column names

workingdata <- cbind(workingdata, YRchange) # join dataframes

workingdata <- unite(workingdata, ppid_trialn, ppid, trialn, sep = "_") # create unique ppid_trialn ID

workingdatatimecourse <- workingdata %>%
  group_by(ppid_trialn) %>%
  mutate(anchored_timestamp = timestamp - min(timestamp)) %>%
  filter(anchored_timestamp<=min(anchored_timestamp)+4) %>%
  ungroup() # create anchored timestamp of 4 seconds for each ppid and trial number

################## This is only necessary for average thresholding ######################

window <- 7 #number of observation to average over

workingdatatimecourse  <- data.frame(workingdatatimecourse, RMEAN = NA) # create RMEAN column

workingdatatimecourse[1:(nrow(workingdatatimecourse) - window + 1),]$RMEAN <-  rollmean(workingdatatimecourse$YawRateChange, k=window) # uses rollmean to calculate the average of the "window" you set, in this case an average over 7 observations (the current line and the 6 ahead).

workingdatatimecourse[is.na(workingdatatimecourse)] <- 0 # set NA values to 0. This is because the last observations will be NA as you don't have enough to average over. Unsure how else to get around this

################## This is only necessary for average thresholding ######################

# determine reaction time for when average yaw rate change is above threshold 
workingdatathreshold <-workingdatatimecourse %>%
  group_by(ppid_trialn) %>%
  filter(abs(RMEAN) > yawratechange_threshold) %>%
  filter(row_number() == 1) %>%
  ungroup() %>%
  transmute(ppid_trialn, heading, cameraoffset, SWAThres = SWA, FirstSteeringTime = anchored_timestamp, ThresWorld_x = World_x, ThresWorld_z = World_z, ThresWorldYaw = WorldYaw, ThresYawRate_seconds = YawRate_seconds, ThresYawRateChange = YawRateChange, AverageYawRateChangeThreshold = RMEAN)  #use transmute to rename for future join, ungroup first to allow for column rename of grouping variable

# Here SWA angle is redundent as it only takes the SWA for when the change in yaw rate is over the threshold... I'm interested in ThresYawRateChange (first change in yaw rate over threhsold) and FirstYawRateChangeTimeThres (first timestamp where yaw rate change is over threshold).

#Only thing extra would be to calculate frame rate (60 frames) (ask Richard), and then multiply by change in yaw rate to get yaw rate per second per second.

```

```{r timecourse plotting, echo=FALSE}
library(ggplot2)
library(dplyr)
library(tidyr)

######## -2 heading ##########

minus2 <- workingdatatimecourse %>%
  filter(heading == -2)

ggplot(minus2, aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line() +
  ggtitle("-2 heading") +
  scale_y_continuous(limits = c(-0.50, 0.75))

######## -1 heading ##########

minus1 <- workingdatatimecourse %>%
  filter(heading == -1)

ggplot(minus1, aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line() +
  ggtitle("-1 heading") +
  scale_y_continuous(limits = c(-0.50, 0.75))

######## 0 heading ##########

zero <- workingdatatimecourse %>%
  filter(heading == 0)

ggplot(zero, aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line() +
  ggtitle("0 heading") +
  scale_y_continuous(limits = c(-0.50, 0.75))

######## +1 heading ##########

plus1 <- workingdatatimecourse %>%
  filter(heading == 1)

ggplot(plus1, aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line() +
  ggtitle("+1 heading") +
  scale_y_continuous(limits = c(-0.50, 0.75))

######## +2 heading ##########

plus2 <- workingdatatimecourse %>%
  filter(heading == 2)

ggplot(plus2, aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line() +
  ggtitle("+2 heading") +
  scale_y_continuous(limits = c(-0.50, 0.75))


```

```{r mean and median first steering adjustment}
library(dplyr)

workingdatathreshold %>%
  group_by(heading) %>%
  summarise(meanFirstSteeringTime = mean(FirstSteeringTime, na.rm = TRUE), medianFirstSteeringTime = median(FirstSteeringTime))

```
I think the plots do show a differece in where the peaks occur for headings of different angles. However these are not reflected in the corresponding mean values do the threshold that is being used i.e. the mean of the first timestamp where yaw rate change is above threshold.

Instead I need to create a threshold that selects the final value after 10 frames of consecutive yaw rate change thus indicating a proper turn for each heading.

```{r boxplots for all angles}
library(dplyr)
library(ggplot2)

ggplot(workingdatathreshold, aes(as.factor(heading), FirstSteeringTime)) +
  geom_boxplot() +
  ggtitle("First steering time across heading angles: boxplots") +
  xlab("Heading angle (degrees)") +
  ylab("Time until first steering correction (s)")
  
```

```{r averaging across all timecourses for each heading (unsure if this is doing what I want)}
library(dplyr)
library(ggplot2)

#### -2 ####

minus2 <- minus2 %>%
  group_by(ppid_trialn, anchored_timestamp) %>%
  mutate(meanYRC = mean(YawRateChange))

ggplot(minus2, aes(x = anchored_timestamp, y = meanYRC)) +
  geom_line() +
  scale_y_continuous(limits = c(-0.50, 0.75))

#### -1 ####

minus1 <- minus1 %>%
  group_by(ppid_trialn, anchored_timestamp) %>%
  mutate(meanYRC = mean(YawRateChange))

ggplot(minus1, aes(x = anchored_timestamp, y = meanYRC)) +
  geom_line() +
  scale_y_continuous(limits = c(-0.50, 0.75))

#### 0 ####

zero <- zero %>%
  group_by(ppid_trialn, anchored_timestamp) %>%
  mutate(meanYRC = mean(YawRateChange))

ggplot(zero, aes(x = anchored_timestamp, y = meanYRC)) +
  geom_line() +
  scale_y_continuous(limits = c(-0.50, 0.75))

#### +1 ####

plus1 <- plus1 %>%
  group_by(ppid_trialn, anchored_timestamp) %>%
  mutate(meanYRC = mean(YawRateChange))

ggplot(plus1, aes(x = anchored_timestamp, y = meanYRC)) +
  geom_line() +
  scale_y_continuous(limits = c(-0.50, 0.50))

#### +2 ####

plus2 <- plus2 %>%
  group_by(ppid_trialn, anchored_timestamp) %>%
  mutate(meanYRC = mean(YawRateChange))

ggplot(plus2, aes(x = anchored_timestamp, y = meanYRC)) +
  geom_line() +
  scale_y_continuous(limits = c(-0.50, 0.50))

```

```{r boxplots for all angles}
library(dplyr)
library(ggplot2)

ggplot(workingdatathreshold, aes(as.factor(heading), FirstSteeringTime)) +
  geom_boxplot() +
  ggtitle("First steering time across heading angles: boxplots") +
  xlab("Heading angle (degrees)") +
  ylab("Time until first steering correction (s)")
  
```

**Below is old code for plotting positive and negative headings - not necessary at the moment**


```{r plotting positive angles, echo=TRUE}

library(ggplot2)
library(dplyr)

positive_offset <- workingdatafinal %>%
  filter(heading >= 0, FirstSteeringTime > 0) # creates dataframe with only positive angle offsets and removes trials where SWA was already above threshold at the start of the time

# input FirstSteeringTime > 0.2 & FirstSteeringTime < 1.6 to remove outliers

ggplot(positive_offset, aes(x = heading, y = FirstSteeringTime)) +
  geom_jitter() +
  geom_smooth() +
  ggtitle("First steering time across heading angles") +
  xlab("Heading angle (degrees)") +
  ylab("Time until first steering correction (s)")

ggplot(positive_offset, aes(as.factor(heading), FirstSteeringTime)) +
  geom_boxplot() +
  ggtitle("First steering time across heading angles: boxplots") +
  xlab("Heading angle (degrees)") +
  ylab("Time until first steering correction (s)")

```

```{r plotting negative offsets, echo=TRUE}

library(ggplot2)
library(dplyr)

negative_offset <- workingdatafinal %>%
  filter(heading <= 0, FirstSteeringTime > 0)
  # creates dataframe with only positive angle offsets and removes trials where SWA was already above threshold at the start of the time

# input FirstSteeringTime > 0.2 & FirstSteeringTime < 1.3 to remove outliers

ggplot(negative_offset, aes(x = heading, y = FirstSteeringTime)) +
  geom_jitter() +
  geom_smooth() +
  ggtitle("First steering time across heading angles") +
  xlab("Heading angle (degrees)") +
  ylab("Time until first steering correction (s)")

ggplot(negative_offset, aes(as.factor(heading), FirstSteeringTime)) +
  geom_boxplot() +
  ggtitle("First steering time across heading angles: boxplots") +
  xlab("Heading angle (degrees)") +
  ylab("Time until first steering correction (s)")


```

