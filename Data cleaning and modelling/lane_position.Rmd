---
title: "lane_position"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load libraries}

library(dplyr)
library(tidyr)
library(ggplot2)

```

```{r load in full datasets}
# rm(list = ls()) 
# full datasets
# set working directory on office laptop
setwd("C:/Users/pscmgo/OneDrive for Business/PhD/Project/Experiment_Code/Straights/Full_Data") 
# setwd("C:/Users/pscmgo/OneDrive for Business/PhD/Project/Experiment_Code/Straights/test_example/Full_Data") 

# set working directory on personal laptop
# setwd("C:/Users/Courtney/Documents/PhD/Project/Experiment_code/Straights/Full_Data")
# setwd("C:/Users/Courtney/Documents/PhD/Project/Experiment_code/Straights/test_example/Full_Data")
temp = list.files(pattern = c("BenLui17_")) # list all CSV files in the directory
myfiles = lapply(temp, read.csv) # read these CSV in the directory
workingdata <- do.call(rbind.data.frame, myfiles) # convert and combine the CSV files into dataframe

```

```{r create unique ID tag and differentiate yaw rate}

upperthreshold = 0.13
lowerthreshold = 0.05

workingdata <- unite(workingdata, ppid_trialn, ppid, trialn, sep = "_") # create unique ppid_trialn ID

workingdata <- workingdata %>%
  mutate(YawRateChange = YawRate_seconds - c(0, YawRate_seconds[-length(YawRate_seconds)])) %>% # difference in yaw rate
  group_by(ppid_trialn) %>%
  mutate(frame = row_number()) %>%
  ungroup()

```

```{r collapsing across heading values}

negativetimecourse <- workingdata %>%
  dplyr::filter(heading < 0) %>%
  mutate(heading = abs(heading)) %>%
  mutate(YawRateChange = abs(YawRateChange))

positivetimecourse <- workingdata %>%
  dplyr::filter(heading > 0) %>%
  mutate(heading = abs(heading)) %>%
  mutate(YawRateChange = YawRateChange)
  
zerotimecourse <- workingdata %>%
  dplyr::filter(heading == 0) %>%
  mutate(heading = abs(heading)) 

workingdata <- rbind(negativetimecourse, positivetimecourse, zerotimecourse)

rm(negativetimecourse, positivetimecourse, zerotimecourse)


```

```{r selecting start and end world yaw values}

# obtains starting coordinates for every trial
trialstartcoords <- workingdata %>%
  group_by(ppid_trialn) %>% # group by trials
  slice(1) %>% # slice the first value
  ungroup() %>%
  transmute(ppid_trialn, StartWorld_x = World_x, StartWorld_z = World_z, StartWorldYaw = WorldYaw) # save values

# obtain coordinates at first steering response for every trial 
threshcoords <- workingdata %>%
  group_by(ppid_trialn) %>%
  dplyr::filter(max(YawRateChange) > upperthreshold, min(YawRateChange) < lowerthreshold) %>% # filter lowest yaw rate change smaller than the lower theshold, # filter largest yaw rate change greater than the upper threshold
  slice(1:min(which(YawRateChange > upperthreshold, 1))) %>% # slice from the first yaw value, to the first yaw value above the upper thrshold
  slice(min(which(YawRateChange > lowerthreshold, 1))) %>% # slice the row at the minimum yaw rate above the lower threshold to get start of the response
  ungroup() %>%
  transmute(ppid_trialn, heading, ThreshWorld_x = World_x, ThreshWorld_z = World_z, ThreshWorldYaw = WorldYaw, ThreshYawRateChange = YawRateChange)

dat <- merge(trialstartcoords, threshcoords, by = "ppid_trialn")

rm(trialstartcoords, threshcoords)


# obtains ending coordinates for every trial
# trialendcoords <- workingdata %>%
#   group_by(ppid_trialn) %>% # group by trials
#   slice(n()) %>% # slice last values
#   ungroup() %>%
#   transmute(EndWorld_x = World_x, EndWorld_z = World_z, EndWorldYaw = WorldYaw) # save values
# 
# start_end <- cbind(trialstartcoords, trialendcoords)

```

Above code selects the world yaw value at the very beginning of the trial (i.e. when the line is not visible) and at the moment of the first steering response.

```{r computing theta angle}


dat <- dat %>%
  group_by(ppid_trialn) %>%
  mutate(ComputedHeading = ThreshWorldYaw - StartWorldYaw) %>%
  mutate(ComputedHeading = abs(ComputedHeading)) %>%
  mutate(ComputedHeading_radians = ComputedHeading / 180 * pi) %>%
  mutate(ComputedErrorRate = 1 / (sin(ComputedHeading_radians) * 10))
  
# radians conversion = (variable / 180 *pi)

```

Above code computes heading angle whilst accounting for carry over from the resetting of the steering wheel angle

To do this, I take the yaw when the response was triggered, and subtract from it the yaw at the beginning of trial. I then take the abosolute of this to get the computed heading angle in degrees.

```{r computing angle for WorldYaw that is near 360 degrees}

notproblem <- dat %>%
  filter(ComputedHeading < 350)

problem <- dat %>%
  filter(ComputedHeading >= 350) %>%
  mutate(ComputedHeading = 360 - ComputedHeading)

dat <- rbind(notproblem, problem)

rm(notproblem, problem)

```

Problem is, world yaw is measured in degrees. Thus when there is a high world yaw (near 360 degrees) minus a small one at the start, it creates a problems... converting to radians does not solve this problem.

However if take the values that are near 360 degrees, subtract 360 degrees from them and then perform the calculation, this solves the problem.

```{r computing hypotenuse}

dat <- dat %>%
  group_by(ppid_trialn) %>%
  mutate(a = (ThreshWorld_x - StartWorld_x)^2 + (ThreshWorld_z - StartWorld_z)^2) %>%
  mutate(hypo = sqrt(a))

```

Above code computes the hypotenuse i.e. the longest side of a triangle (trajectory of the offset heading). This is computed by subtracting the starting position X and Z coordinates from the end position X and Z coordinates, squaring the result and adding them to values together. The square root is then taken.


```{r computing lane position}

dat <- dat %>%
  mutate(lane_position = sin(ComputedHeading) * hypo)

```

Finally, you take the sine of the computed heading and multiple by the hypotenuse to calculate the lane position in metres.

Currently, this is calculating the lane position from the very start of the trial (when the line is not visible) to when the response was triggerd i.e when the RT value is obtained.

```{r comparing threshold model lane position values to data}

# computing threshold value in metres for each error rate value
modellingdata <- modellingdata %>%
  group_by(error_rate) %>%
  mutate(thresh = error_rate * FirstSteeringTime)

# average threshold value for each error rate value according to constructed threshold model
modellingdata %>%
  group_by(heading) %>%
  summarise(meanLanePosition = mean(thresh))

# average threshold value for each error rate value according to data
dat %>%
  group_by(heading) %>%
  summarise(meanLanePosition = mean(lane_position))

```


