---
title: "AnalysisRUpperLowerThreshold"
output: html_document
---

```{r setup, include=FALSE}
# chooseCRANmirror(graphics=FALSE, ind=1) # uncomment for knitting
# rm(list = ls()) # clear workspace
knitr::opts_chunk$set(echo = TRUE)
install.packages(ggplot2) # for plots
install.packages(dplyr) # for manipulating data frames
install.packages(tidyr) # for tidying data (uniting columns)
install.packages(TTR) # for smoothing data with mean of observations
install.packages(zoo) # package for rolling mean (rollmean function)
install.packages(skimr) # generates summary of data
install.packages(car) # to perform levenes and anova
install.packages(apaTables) # to create apa table
install.packages(WRS2) # for non-parametric anova
install.packages(compute.es) # for ancova type 3 method
install.packages(multcomp) # post hoc for type 3 method ancova
install.packages(lmPerm) # non-parametric ancova
install.packages(e1071) # for calculating skewness
install.packages(ggpubr) # for interactions plots and boxplots
install.packages(effsize) # for calculating effect sizes
install.packages(gganimate) # animate plots
install.packages(gifski) # animate plots
install.packages(png)
install.packages(transformr)
install.packages(signal) # package needed for sgolayfilt function for steering magnitude 
install.packages(conflicted) # heloful package to show when packages have conflicted functions # conflict_prefer("filter", "dplyr") means filter function from dplyr is prioritised

# install.packages(matlabr)
# install.packages(magrittr)

# full datasets
setwd("C:/Users/pscmgo/OneDrive for Business/PhD/Project/Experiment_Code/Straights/Full_Data") # set working directory on personal laptop
# setwd("C:/Users/Courtney/Documents/PhD/Project/Experiment_code/Straights/Full_Data")
temp = list.files(pattern = c("BenLui17_")) # list all CSV files in the directory
myfiles = lapply(temp, read.csv) # read these CSV in the directory
workingdata <- do.call(rbind.data.frame, myfiles) # convert and combine the CSV files into dataframe


# pilot dataset
# setwd("M:/PhD/Project/Experiment_Code/Straights/Pilot")
# file_names <- dir("M:/PhD/Project/Experiment_Code/Straights/Pilot") #where you have your files
# workingdata <- do.call(rbind, lapply(file_names, read.csv))

```

```{r demographic information}
library(dplyr)
library(tidyr)

# age

workingdata %>%
  summarise(mean(age), max(age), min(age), median(age), sd(age))

# driving license time

workingdata %>%
  summarise(mean(licenseTime), max(licenseTime), min(licenseTime), median(licenseTime), sd(licenseTime))

# gender split 

gender <- workingdata %>%
  group_by(pNum, gender) %>%
  summarise(count = n()) %>%
  ungroup()

female <- filter(gender, gender == 1) 
male <- filter(gender, gender == 2)

length(female$gender) / length(gender$gender) * 100 
length(male$gender) / length(gender$gender) * 100

```

```{r altering StraightVisible variable (for new experiment design)}
library(dplyr)
library(tidyr)

workingdata <- unite(workingdata, ppid_trialn, ppid, trialn, sep = "_") # create unique ppid_trialn ID

# sapply(workingdata, class) # identifies class of each column

workingdata$StraightVisible <- as.numeric(workingdata$StraightVisible) # changes factor to numeric, 1 = false, 2 = true

workingdata <- workingdata %>%
group_by(ppid_trialn) %>%
dplyr::filter(StraightVisible == 2) %>% # filter for only data where central line is visible
mutate(frame = row_number()) # create frame number column

```


```{r  thresholds, removing trials with dropped frames, calculating yaw rate change}
library(dplyr)
library(tidyr)
library(TTR)
# library(hemm)
library(searcher)
# library(skimr)
# init_hemm()

# change in steering 
# magnitudethreshold = 0.140
upperthreshold = 0.13 # 0.105 #  # upper threshold for consistent steering response
lowerthreshold = 0.05 # 0.001 lower threshold for when response initiated - lowest of the IQRs for each mean YawRateChange condition

workingdata <- workingdata %>%
  mutate(YawRateChange = YawRate_seconds - c(0, YawRate_seconds[-length(YawRate_seconds)])) %>% #difference in yaw rate
  group_by(ppid_trialn) %>%
  mutate(frame = row_number()) %>%
  ungroup()

```


```{r anchoring timestamps at 2.5 seconds and calculating frames column}
library(dplyr)

workingdata <- workingdata %>%
  group_by(ppid_trialn) %>%
  mutate(anchored_timestamp = timestamp - min(timestamp)) %>%
  dplyr::filter(anchored_timestamp <= min(anchored_timestamp) + 2.5) %>% # add for seconds fro the original data 
  ungroup() # create anchored timestamp and then only select first 2.5 seconds of data for each each ppid_trialn (only interested in the first steering adjustment as this point)

```


```{r golay smoothing and inverting data}
library(dplyr)
library(tidyr)
library(signal)

# inverting yaw rate signal and collapsing heading conditions

negativetimecourse <- workingdata %>%
  dplyr::filter(heading < 0) %>%
  mutate(heading = abs(heading)) %>%
  mutate(YawRateChange = -(YawRateChange))

positivetimecourse <- workingdata %>%
  dplyr::filter(heading >= 0) %>%
  mutate(heading = abs(heading)) %>%
  mutate(YawRateChange = (YawRateChange))

workingdata <- rbind(negativetimecourse, positivetimecourse)

# golay filter data

workingdata <- workingdata %>%
  group_by(ppid_trialn) %>%
  mutate(YawRateChange = sgolayfilt(YawRateChange, n = 11)) %>%
  ungroup()

```

```{r number of trials be condition - overall}
library(dplyr)

workingdata %>%
  group_by(ppid_trialn) %>%
  summarise(headingtype = head(heading, n = 1)) %>% # select first heading value for each trial
  ungroup() %>% 
  group_by(headingtype) %>% # group the heading values
  summarise(heading = n()) %>% # calculate the number of each heading
  ungroup()

```

```{r number of trials per condition for magnitude data}

magnitudedata %>%
  group_by(heading.x) %>%
  summarise(heading = n())

```


```{r formulating response start magnitude data}
library(dplyr)
library(tidyr)

# code below is identical to the RT data selection - both trying to find the same thing (start of the response)
mag_response_start <- workingdata %>% 
select(ppid_trialn, heading, frame, YawRateChange, anchored_timestamp) %>% 
group_by(ppid_trialn) %>%
  filter(max(YawRateChange) > upperthreshold, min(YawRateChange) < lowerthreshold) %>% # filter lowest yaw rate change smaller than the lower theshold, # filter largest yaw rate change greater than the upper threshold
  slice(1:min(which(YawRateChange > upperthreshold, 1))) %>% # slice from the first yaw value, to the first yaw value above the upper thrshold
  slice(min(which(YawRateChange > lowerthreshold, 1))) %>% # slice the row at the minimum yaw rate above the lower threshold to get start of the response
  ungroup() %>%
  transmute(ppid_trialn, heading, start_frame = frame, start_yaw = YawRateChange, FirstSteeringTime = anchored_timestamp) %>%
  # mutate(steering_zscore = scale(FirstSteeringTime)) %>%
  mutate(EarlyResponses = FirstSteeringTime <= 0.15)

# filters out early responses
mag_response_start <- mag_response_start %>%
  filter(EarlyResponses == FALSE)

```

```{r formulating response peak magnitude data}
library(dplyr)
library(tidyr)

mag_response_peak <- workingdata %>%
select(ppid_trialn, heading, frame, YawRateChange, anchored_timestamp) %>%
group_by(ppid_trialn) %>%
mutate(peakYaw = max(YawRateChange)) %>%
filter(max(YawRateChange) > upperthreshold, min(YawRateChange) < lowerthreshold) %>% 
slice(1:max(which(YawRateChange > upperthreshold, 1))) %>%
slice(max(which(YawRateChange == peakYaw))) %>%
ungroup() %>%
transmute(ppid_trialn, heading, peak_frame = frame, peak_yaw = YawRateChange, peak_time = anchored_timestamp)

# merge response start and response peak dataframes
magnitudedata <- merge(mag_response_start, mag_response_peak, by = "ppid_trialn")

```

```{r calculating genuine responses, formulating threshold RT data}
library(zoo)
library(dplyr)
library(tidyr)
library(TTR)

workingdatathresholdUnsmooth <- workingdatatimecourseUnsmooth %>%
  group_by(ppid_trialn) %>%
  filter(max(YawRateChange) > upperthreshold, min(YawRateChange) < lowerthreshold) %>% # filter lowest yaw rate change smaller than the lower theshold, # filter largest yaw rate change greater than the upper threshold
  slice(1:min(which(YawRateChange > upperthreshold, 1))) %>% # slice from the first yaw value, to the first yaw value above the upper thrshold
  slice(min(which(YawRateChange > lowerthreshold, 1))) %>% # slice the row at the minimum yaw rate above the lower threshold to get start of the response
  ungroup() %>%
  transmute(ppid_trialn, heading, cameraoffset, SWAThres = SWA, FirstSteeringTime = anchored_timestamp, ThresWorld_x = World_x, ThresWorld_z = World_z, ThresWorldYaw = WorldYaw, ThresYawRate_seconds = YawRate_seconds, gender = gender, age = age, licenseTime = licenseTime, contacts_glasses = contacts_glasses, ThresYawRateChange = YawRateChange) %>%
  mutate(EarlyResponses = FirstSteeringTime <= 0.15)
  
```


```{r timecourse plotting of yaw rate change - UNSMOOTH}
library(ggplot2)
library(dplyr)
# library(gganimate)
# library(gifski)
# library(png)
# library(transformr)

workingdatatimecourseUnsmooth <- workingdatatimecourseUnsmooth %>%
  filter(EarlyResponses == FALSE)

############################################################### MEAN PLOTS ########################################################

######## 0 heading ##########

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == 0), aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line(show.legend = FALSE) +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == 0) %>%
               summarise(meanFirstSteeringTime = mean(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = meanFirstSteeringTime)) +
  ggtitle("0 heading - unsmoothed")

####### +0.5 heading #########

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == 0.5), aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line(show.legend = FALSE) +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == 0.5) %>%
               summarise(meanFirstSteeringTime = mean(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = meanFirstSteeringTime)) +
  ggtitle("0.5 heading - unsmoothed")

######## +1 heading ##########

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == 1), aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line(show.legend = FALSE) +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == 1) %>%
               summarise(meanFirstSteeringTime = mean(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = meanFirstSteeringTime)) +
  ggtitle("+1 heading - Unsmoothed")

######## +1.5 heading ########

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == 1.5), aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line(show.legend = FALSE) +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == 1.5) %>%
               summarise(meanFirstSteeringTime = mean(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = meanFirstSteeringTime)) +
  ggtitle("1.5 heading - unsmoothed")

######## +2 heading ##########

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == 2), aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line(show.legend = FALSE) +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == 2) %>%
               summarise(meanFirstSteeringTime = mean(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = meanFirstSteeringTime)) +
  ggtitle("+2 heading - unsmoothed")



################################################################## MEDIAN PLOTS ######################################################


######## 0 heading ##########

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == 0), aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line(show.legend = FALSE) +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == 0) %>%
               summarise(medianFirstSteeringTime = median(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = medianFirstSteeringTime)) +
  ggtitle("0 heading - unsmoothed")
               
######## 0.5 heading ##########

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == 0.5), aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line(show.legend = FALSE) +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == 0.5) %>%
               summarise(medianFirstSteeringTime = median(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = medianFirstSteeringTime)) +
  ggtitle("0.5 heading - unsmoothed")

######## 1 heading ##########

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == 1), aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line(show.legend = FALSE) +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == 1) %>%
               summarise(medianFirstSteeringTime = median(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = medianFirstSteeringTime)) +
  ggtitle("+1 heading - Unsmoothed")

######## 1.5 heading ##########

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == 1.5), aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line(show.legend = FALSE) +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == 1.5) %>%
               summarise(medianFirstSteeringTime = median(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = medianFirstSteeringTime)) +
  ggtitle("1.5 heading - unsmoothed")

######## 2 heading ##########

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == 2), aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line(show.legend = FALSE) +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == 2) %>%
               summarise(medianFirstSteeringTime = median(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = medianFirstSteeringTime)) +
  ggtitle("+2 heading - unsmoothed")

###### facet wrapped plot for median value ######

ggplot(data = workingdatatimecourseUnsmooth, aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line(show.legend = FALSE) +
  geom_vline(data = workingdatathresholdUnsmooth %>%
               summarise(medianFirstSteeringTime = median(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = medianFirstSteeringTime), color = "black", linetype = "dashed") +
  facet_wrap( ~ heading) +
  scale_y_continuous(name="Yaw rate change", limits=c(-1, 2.5)) +
  scale_x_continuous(name="Timestamp (secs)", limits=c(0, 2.5))

###### facet wrapped plot for median AND mean value ######

ggplot(data = workingdatatimecourseUnsmooth, aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line(show.legend = FALSE) +
  geom_vline(data = workingdatathresholdUnsmooth %>%
               summarise(medianFirstSteeringTime = median(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = medianFirstSteeringTime), color = "red", linetype = "dashed") +
  geom_vline(data = workingdatathresholdUnsmooth %>%
               summarise(meanFirstSteeringTime = mean(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = meanFirstSteeringTime), color = "blue", linetype = "dashed") +
  facet_wrap( ~ heading) +
  scale_y_continuous(name="Yaw rate change", limits=c(-1, 2.5)) +
  scale_x_continuous(name="Timestamp (secs)", limits=c(0, 2.5))
  
```

```{r genuine repsonse numbers}
library(dplyr)

workingdatathresholdUnsmooth %>%
  filter(EarlyResponses == TRUE) %>%
  group_by(heading) %>%
  summarise(NumberOfEarlyRespones = n())

workingdatathresholdUnsmooth %>%
  filter(Genuine_Response == FALSE) %>%
  group_by(heading) %>%
  summarise(NumberOfNonGenuineResponses = n())

genuine <- workingdatathresholdUnsmooth %>%
  filter(Genuine_Response == TRUE & EarlyResponses == FALSE) %>%
  group_by(heading) %>%
  summarise(trials = n()) %>%
  ungroup() # overall number of trials in each conditon after early and non-genuine responses have been removed

workingdatathresholdUnsmooth %>%
  group_by(heading) %>%
  summarise(trials = n()) # overall number of trials in each condition

# percentage of trials kept after removing non-genuine responses
heading <- c('-2', '-1.5', '-1', '-0.5', '0', '0.5', '1', '+1.5', '+2')
percentagetrialskept <- (genuine$trials/overall$trials * 100)
per <- data.frame(heading, percentagetrialskept) # percentage of trials kept after data cleaning 
View(per)

total_trials <- length(unique(workingdata$ppid_trialn)) # total trials from all participants

length(unique(workingdatathresholdUnsmooth$ppid_trialn)) # number of valid trials when unsmoothed
length(unique(workingdatathresholdSmooth$ppid_trialn)) # number of valid trials when smoothed

```


```{r timecourse plotting for individual trials - UNSMOOTH, fig.height = 18, fig.width = 26}
library(ggplot2)
library(dplyr)

#### 0 ########

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == 0), aes(x = anchored_timestamp, y = YawRateChange)) +
  geom_line() +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == 0), aes(xintercept = FirstSteeringTime, color = EarlyResponses)) +
  facet_wrap( ~ ppid_trialn) +
  ggtitle("0 heading - unsmoothed")

##### +0.5 #####

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == 0.5), aes(x = anchored_timestamp, y = YawRateChange)) +
  geom_line() +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == 0.5), aes(xintercept = FirstSteeringTime, color = EarlyResponses)) +
  facet_wrap( ~ ppid_trialn) +
  ggtitle("0.5 heading - unsmoothed")


###### +1 ######

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == 1), aes(x = anchored_timestamp, y = YawRateChange)) +
  geom_line() +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == 1), aes(xintercept = FirstSteeringTime, color = EarlyResponses)) +
  facet_wrap( ~ ppid_trialn) +
  ggtitle("+1 heading - unsmoothed")

#### 1.5 ####

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == 1.5), aes(x = anchored_timestamp, y = YawRateChange)) +
  geom_line() +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == 1.5), aes(xintercept = FirstSteeringTime, color = EarlyResponses)) +
  facet_wrap( ~ ppid_trialn) +
  ggtitle("+1.5 heading - unsmoothed")

##### +2 #####

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == 2), aes(x = anchored_timestamp, y = YawRateChange)) +
  geom_line() +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == 2), aes(xintercept = FirstSteeringTime, color = EarlyResponses)) +
  facet_wrap( ~ ppid_trialn) +
  ggtitle("+2 heading - unsmoothed")

```


```{r boxplots for all angles}
library(dplyr)
library(ggplot2)

ggplot(data = workingdatathresholdUnsmooth, aes(factor(heading_collapsed), FirstSteeringTime)) +
  geom_violin(draw_quantiles = c(0.25, 0.5, 0.75)) +
  stat_summary(fun.y = mean, colour = "red", geom = "point") +
  xlab("Heading angle (degrees)") +
  ylab("Time until first steering correction (secs)")

# violin plot example -> kernal density estimation generates an idea of the distribution. Provides probability calculations for where sample population would sit. 

# middle line represents the median value with lower and upper hinges representing 25th and 75th percentiles

ggplot(data = workingdatathresholdUnsmooth, aes(as.factor(heading), FirstSteeringTime)) +
  geom_boxplot() +
  stat_summary(fun.y = mean, colour = "red", geom = "point") +
  # ggtitle("First steering time across heading angles: UNSMOOTH ALL RESPONSES") +
  xlab("Heading angle (degrees)") +
  ylab("Time until first steering correction (secs)")

ggplot(data = workingdatathresholdSmooth, aes(as.factor(heading), FirstSteeringTime)) +
  geom_boxplot() +
  # stat_summary(fun.y = mean, colour = "red", geom = "point") +
  ggtitle("First steering time across heading angles: SMOOTH ALL RESPONSES") +
  xlab("Heading angle (degrees)") +
  ylab("Time until first steering correction (s)")

##### BOXPLOTS WHERE RESPONSES ARE GENUINE AND NOT TOO LATE

ggplot(data = filter(workingdatathresholdUnsmooth, Genuine_Response == TRUE & EarlyResponses == FALSE), aes(as.factor(heading), FirstSteeringTime)) +
  geom_boxplot() +
  stat_summary(fun.y = mean, colour = "red", geom = "point") +
  xlab("Heading angle (degrees)") +
  ylab("First steering reacton time (s)") 

ggplot(data = filter(workingdatathresholdSmooth, Genuine_Response == TRUE & EarlyResponses == FALSE), aes(as.factor(heading), FirstSteeringTime)) +
  geom_boxplot() +
  # stat_summary(fun.y = mean, colour = "red", geom = "point") +
  ggtitle("First steering time across heading angles: SMOOTH GENUINE RESPONSES") +
  xlab("Heading angle (degrees)") +
  ylab("Time until first steering correction (s)")


  
```


```{r first steering time graphed example, fig.height = 7, fig.width = 15}
# fig.height = 18, fig.width = 26
library(dplyr)
library(ggplot2)

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == 2), aes(x = anchored_timestamp, y = YawRateChange)) +
  geom_line() +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == 2), aes(xintercept = FirstSteeringTime, color = EarlyResponses)) +
  facet_wrap( ~ ppid_trialn) +
  scale_y_continuous(limits = c(-0.60, 0.80)) +
  ggtitle("Visualisation of data pre-processing for +2 heading") +
  xlab("Timestamp (secs)") +
  ylab("Yaw Rate Change") +
  labs(color = "Early Responses") +
  theme(plot.title = element_text(size = 18),
    legend.title = element_text(size = 18), 
    legend.text = element_text(size = 18),
    axis.text.x = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    axis.title = element_text(size = 20))
#   ggsave("Pre-processing_plot.png", width = 5, height = 5, units = "in")

  
  # ggplot(data = filter(workingdatatimecourseUnsmooth, heading == 2, ppid_trialn == "1_2_16"), aes(x = anchored_timestamp, y = YawRateChange)) +
  # geom_line() +
  # geom_vline(data = filter(workingdatathresholdUnsmooth, heading == 2, ppid_trialn == "1_2_16"), aes(xintercept = FirstSteeringTime)) +
  # scale_y_continuous(limits = c(-0.60, 0.80)) +
  # ggtitle("A) Genuine response") +
  # xlab("Timestamp (secs)") +
  # ylab("Yaw Rate Change")
  # ggsave("Pre-processing_plot.png", width = 5, height = 5, units = "in")
```

```{r mean first steering adjustment}
library(dplyr)

workingdatathresholdUnsmooth %>%
  group_by(heading_collapsed) %>%
  summarise(meanFirstSteeringTimeTRUE = mean(FirstSteeringTime, na.rm = TRUE), medianFirstSteeringTime = median(FirstSteeringTime), sdFirstSteeringTime = sd(FirstSteeringTime), minFirstSteeringTime = min(FirstSteeringTime), maxFirstSteeringTime = max(FirstSteeringTime))

```

```{r normality assumptions tests}
library(ggplot2)
library(dplyr)
library(car) # anova and levenes table
library(apaTables) # for apa tables
library(MBESS) # for apa tables
library(WRS2) # for non-parametric
library(e1071) # for skewness calculation

# skim of the data
skim(clean_smooth_data)

# calculates skewness for each condition
workingdatathresholdUnsmooth %>%
  group_by(heading) %>%
  summarise(skew = skewness(FirstSteeringTime))

# histogram with normality curves
ggplot(workingdatathresholdUnsmooth, aes(x = FirstSteeringTime)) +
  geom_histogram(aes(y = ..density..)) +
  stat_function(
		fun = dnorm, 
		args = with(workingdatathresholdUnsmooth, c(mean = mean(FirstSteeringTime), sd = sd(FirstSteeringTime)))
	) + 
  facet_wrap( ~ heading)

# shapiro-wilk test for each heading - significant means not normally distributed
workingdatathresholdUnsmooth2 <- filter(workingdatathresholdUnsmooth, heading == -0.5)
shapiro.test(workingdatathresholdUnsmooth2$FirstSteeringTime)

# need to make grouping variable a factor for levene's test - doesn't assume normality so significant means data is not normal
workingdatathresholdUnsmooth$heading_fact<-as.factor(workingdatathresholdUnsmooth$heading)
workingdatathresholdUnsmooth$groupSign_fact<-as.factor(workingdatathresholdUnsmooth$groupSign)
workingdatathresholdUnsmooth$absHeading_fact<-as.factor(workingdatathresholdUnsmooth$absHeading)
leveneTest(FirstSteeringTime ~ heading_fact, data = workingdatathresholdUnsmooth)

```

```{r anova tests}
library(ggplot2)
library(dplyr)
library(car) # anova and levenes table
library(apaTables) # for apa tables
library(MBESS) # for apa tables
library(WRS2) # for non-parametric
library(ggpubr) # for interaction plots/boxplots
library(effsize) # for calculating effect sizes

# Anova style 1
Anova1 <- aov(FirstSteeringTime ~ heading_fact, data = workingdatathresholdUnsmooth)
summary(Anova1)

# Post-hoc tests (only to be used on anova1 type of anova)
resultTukey <-TukeyHSD(Anova1)
resultTukey

# Anova style 2 ( linear model)
Anova2 <- lm(FirstSteeringTime ~ heading_fact, data = workingdatathresholdSmooth)
summary(Anova2)

# Post hoc tests for style 2 (linear model)
posth = glht(Anova2, linfct = mcp(heading_fact = "Tukey"))  
summary(posth)

# creates nice table with effect size
apa.aov.table(Anova1, filename = "APA_Anova_Table.doc", table.number = 1)

####### NON-PARAMETRIC ######

# Anova for non-parametric (heteroscedastic one-way ANOVA for trimmed means). It uses a generalization of Welch's method.
t1way(FirstSteeringTime ~ heading_fact, data = workingdatathresholdSmooth)

# Anova for non-parametric (heteroscedastic one-way ANOVA for trimmed means) and bootstrapping
t1waybt(FirstSteeringTime ~ heading_fact, data = clean_smooth_data, nboot = 10000)

# Post hoc for non-parametric anova
lincon(FirstSteeringTime ~ heading_fact, data = clean_smooth_data) 

# Anova for non-parametric (using medians values)
med1way(FirstSteeringTime ~ heading_fact, data = workingdatathresholdSmooth, iter = 10000)

```

```{r two-way ANOVA plots and analysis}
library(car) # anova and levenes table
library(ggpubr) # for interaction plots/boxplots

# generates sign condition and absolute heading condition for a two-way ANOVA
workingdatathresholdUnsmooth <- workingdatathresholdUnsmooth %>%
  mutate(groupSign = sign(heading)) %>%
  mutate(absHeading = abs(heading)) 

# boxplots for two-way ANOVA
ggboxplot(workingdatathresholdUnsmooth, x = "absHeading_fact", y = "FirstSteeringTime", color = "groupSign_fact",
          palette = c("#00AFBB", "#E7B800"))

# interaction plot for two-way ANOVA
ggline(workingdatathresholdUnsmooth, x = "absHeading_fact", y = "FirstSteeringTime", color = "groupSign_fact",
       add = c("mean_se", "dotplot"),
       palette = c("#00AFBB", "#E7B800"))

twowayAnova <- aov(FirstSteeringTime ~ absHeading_fact * groupSign_fact, data = workingdatathresholdUnsmooth)
summary(Anova1)

# Post-hoc tests (only to be used on anova1 type of anova)
resultTukey <-TukeyHSD(twowayAnova)
resultTukey

```


```{r ancova tests}
library(car)
library(compute.es) # ancova using type 3 method
library(multcomp) # post hoc for ancova type 3 method
library(lmPerm)
# allows you to partial out other observations within your data (i.e. initial SWA in my case)


# ancova using anova function but adding the covariates to your grouping variable - significant initialSWA would mean that the effect of the covariate on the main effects was significant
ancova1 <- aov(FirstSteeringTime ~ heading_fact + initialSWA, data = workingdatathresholdSmooth)
summary(ancova1)

resultTukey <-TukeyHSD(ancova1) # this doesn't work for some reason...
resultTukey

# ancova looking at first steering time whislt partialing out initialSWA - using linear model
lm_ancova2 <- lm(FirstSteeringTime ~ heading_fact + initialSWA, data = clean_smooth_data)
anova(lm_ancova2)

# ancova using type 3 method and linear model - significant initialSWA would mean that the effect of the covariate on the main effects was significant
ancova3 <- lm(FirstSteeringTime ~ heading_fact + initialSWA, contrasts = list(heading_fact = contr.sum), data = workingdatathresholdSmooth)
Anova(ancova3, type = "III")

# post hoc for ancova using linear model version
posth = glht(lm_ancova2, linfct = mcp(heading_fact = "Tukey"))  
summary(posth)

##### NON-PARAMETRIC #####

nonpara_ancova <- aovp(FirstSteeringTime ~ heading_fact + initialSWA, data = workingdatathresholdSmooth)
summary(nonpara_ancova)

resultTukey <-TukeyHSD(nonpara_ancova)
resultTukey


```

```{r loading magnitude data from matlab}
setwd("M:/PhD/Project/Experiment_Code/Straights") # set working directory
# setwd("C:/Users/Courtney/Documents/PhD/Project/Experiment_code/Straights")
magnitude <- read.csv("magnitudedata.csv", header = FALSE)

names(data) <- c("heading", "responseStart", "responsePeak", "responseEnd", "YawRateChangeChange", "YawRateChangeTime")

```




OLD CODE




```{r Callum function fo r removing spikes - ask Callum about this}
# library(dplyr)

# steerdata <- steerdata %>% group_by(trialid) %>% mutate(timestamp_diff = append(diff(timestamp),NA))
# 
# #quick function for averaging out implausible fluctuations in yaw-rate due to variations in recorded timestamps.
# correctTimestamp<- 
#   function(x,y){ #x needs to be timestamp_diff, y needs to be yaw signal.
#     Tvec = which(x >.017) # Means dropped frames.
#     len = length(y)
#     for (i in 1:length(Tvec)){
#       p = Tvec[i]
#       t1 = x[p] #dropped frame.
#       t2 = x[p+1] #sometimes this is close to zero. If it is, average the two yaw rates. If it isn't, average the preceding and subsequent.
#       if (p+2 < len){
#         if (t2 < .015){ ##take the corresponding two datapoints in yaw rate and average
#           YR1 = y[p+1] 
#           YR2 = y[p+2]
#           YR_avg = (YR1+YR2) / 2
#           y[p+1] = YR_avg
#           y[p+2] = YR_avg  
#         } else { #means it is an isolated dropped frame. average before and after yaw-rates
#           YR1 = y[p]
#           YR2 = y[p+2]
#           YR_avg = (YR1+YR2) / 2
#           y[p+1] = YR_avg
#         }
#       }
#     }
#     return(y)
#   }
# 
# steerdata <- steerdata %>% group_by(trialid) %>% mutate(newYawRate = correctTimestamp(timestamp_diff,YawRate))
```

