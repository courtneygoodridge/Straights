---
title: "TvA lateral position model predictions"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load packages}
library(ggplot2)
library(dplyr)
library(car)
library(MASS)
library(dplyr)
library(EnvStats)
library(lme4)
library(nlme)
library(tidyr)
library(rstanarm)
library(bayesplot)
library(loo)
library(lmtest)
library(caret)
library(merTools)
library(scales)
library(fitdistrplus)
library(mcr) # orthogonal regression
library(quantreg) # quantile regressions

```

```{r load data}

# rm(list = ls())

# office working directory
setwd("C:/Users/pscmgo/OneDrive for Business/PhD/Project/Experiment_Code/Straights")

temp = list.files(pattern = c("magnitudedata", "*.csv")) # list all CSV files in the directory
myfiles = lapply(temp, read.csv) # read these CSV in the directory
magnitudedata <- do.call(rbind.data.frame, myfiles) # convert and combine the CSV files into dataframe

```


```{r computing error rate for threshold and accumulator}

# compute erro rate metrics
modellingdata <- magnitudedata %>%
  group_by(heading) %>% # group by each heading value
  dplyr::filter(heading > 0) %>% # remove 0 heading trials for modelling data
  mutate(heading_radians = heading / 180 * pi) %>% # convert heading to radians 
  mutate(acc_error_rate = 1 / (sqrt(sin(heading_radians)) * 10)) %>% 
  mutate(thresh_error_rate = 1 / (sin(heading_radians) * 10))


# Jami's calculations 
# mutate(acc_error_rate = sqrt(2) / (sqrt(sin(heading_radians)) * 10)) %>%
# mutate(thresh_error_rate = 1 / (sin(heading_radians) * 10))

```

Here we compute the error rate for Threshold and Accumulator model. The difference being that the Accumulator requires a square root of the sine of heading (still unsure why mathematically).

```{r computing multi-level model for threshold and accumulator}

# model 5: generalised linear mixed effects model (applying gamma distribution with identity link function)

# Threshold model
thresh <- glmer(FirstSteeringTime ~ thresh_error_rate + (1 + thresh_error_rate | pNum), family = Gamma(link = "identity"), data = modellingdata)

# Accumulator model
acc <- glmer(FirstSteeringTime ~ acc_error_rate + (1 + acc_error_rate | pNum), family = Gamma(link = "identity"), data = modellingdata)

```

Computing the model for Threshold and Accumulators in order to generate parameters.

```{r extracting slope and intercept parameters for modelling dataframe}

# obtain coefficients and then intercepts from multi level model - THRESHOLD
thresh_coefficients <- coef(thresh)[["pNum"]]
thresh_intercept <- thresh_coefficients[,1]
thresh_slope <- thresh_coefficients[,2]

# obtain coefficients and then intercepts from multi level model - ACCUMULATOR
acc_coefficients <- coef(acc)[["pNum"]]
acc_intercept <- acc_coefficients[,1]
acc_slope <- acc_coefficients[,2]

# for loop and if statement to input them into modellingdata dataframe
for (i in c(1:19)){
  if (modellingdata$pNum == i){
    modellingdata$thresh_intercept <- thresh_intercept[modellingdata$pNum]
    modellingdata$thresh_slope <- thresh_slope[modellingdata$pNum]
    modellingdata$acc_intercept <- acc_intercept[modellingdata$pNum]
    modellingdata$acc_slope <- acc_slope[modellingdata$pNum]
  }
}

```

Extracting the slope and intercept for each participant from Threshold and Accumulator models.

```{r computing steering onset time for threshold and accumulator}

modellingdata <- modellingdata %>%
  group_by(heading) %>% # group by heading condition
  mutate(ACC_steeringonset = 1 / (sqrt(sin(heading_radians))) * acc_slope + acc_intercept) %>%
  mutate(THRESH_steeringonset = 1 / (sin(heading_radians)) * thresh_slope + thresh_intercept)


# Jami's parametisation  
# mutate(ACC_steeringonset = (sqrt(2) / sqrt(10 * sin(heading_radians))) * acc_slope + acc_intercept) %>%
# mutate(THRESH_steeringonset = (1 / (10 * sin(heading_radians))) * thresh_slope + thresh_intercept)

```

The slope in our linear model corresponds to the "threshold" value. However, we cannot simply use this value for the lateral position threshold. We need to compute this using the threshold slope value for each heading condition for the Threshold and Accumulator model.

For each heading value, we compute the error rate of each model and multiple by out slope threshold and add out non-decision time (intercept). This generates (per heading) the time at steering onset. This is basically using the linear equation to compute time at steering onset for each heading and subject.

```{r computed lateral position for threshold and accumulator - combing data and prediction dataframes}

latpos <- modellingdata %>%
  group_by(heading) %>% # group by heading condition
  mutate(ACC_lateralposition = (sin(heading_radians) * 10) * ACC_steeringonset) %>%
  mutate(THRESH_lateralposition = (sin(heading_radians) * 10) * THRESH_steeringonset) %>%
  summarise(acc = mean(ACC_lateralposition), thresh = mean(THRESH_lateralposition)) %>%
  gather(key = "modeltype", value = "latpos", acc, thresh)


# Jami's parametisation
# mutate(ACC_lateralposition = (sin(heading_radians) * 10) * ACC_steeringonset^2 / 2) %>%
# mutate(THRESH_lateralposition = (sin(heading_radians) * 10) * THRESH_steeringonset) %>%

latpositiondata <- rbind(latpos, dat_latpos) %>%
  mutate(loglatpos = log(latpos))

```

Now we have the time at steering onset, we can calculate out the lateral position at this point. 

For each heading, multiple the speed at which we are moving away from the road-line (sin(heading) * Speed) by the time we are applying the steering onset (calculated at the previous step). The result of this is a lateral position away from the line at steering onset for eaching heading, as predicted by each model.

```{r graphing lateral position predictions and data values - bar graph}

ggplot(dplyr::filter(latpositiondata, modeltype != "data"), aes(x = heading, y = latpos)) +
  geom_bar(colour = "black", stat = "identity") +
  theme_gray() +
  guides(fill = FALSE) +
  xlab("Heading (degrees)") +
  ylab("Lateral position from line (m)") +
  ylim(0, 0.80) +
  theme(axis.title.x = element_text(size = 15), axis.text.x = element_text(size = 15), axis.title.y = element_text(size = 15), axis.text.y = element_text(size = 15), title = element_text(size = 10)) +
  facet_wrap(~ modeltype) +
  ggtitle("Threshold and Acccumulator model predictions of lateral position at steering onset") 

```
These bar charts are a nice visualisation of the the different model predictions from Threshold and Accumulator accounts. The Accumulator model predicts that as heading increases, the lateral position at steering onset also increases. Conversely, the Threshold model proposes that subjects will respond at a fixed absolute error and thus lateral position at steering onset will not vary across conditions. 

```{r graphing lateral position predictions and data values - line graph}

ggplot(dplyr::filter(latpositiondata, modeltype == "data"), aes(x = heading, y = latpos)) +
  geom_line() +
  theme_gray() +
  ggtitle("Plot 1: Lateral position at steering onset for each heading condition")

ggplot(latpositiondata, aes(x = heading, y = latpos, color = modeltype)) +
  geom_line() +
  theme_gray() +
  ggtitle("Plot 2: Threshold and Accumulator model predictions and data")

ggplot(latpositiondata, aes(x = heading, y = log(latpos), color = modeltype)) +
  geom_line() +
  theme_gray() +
  ggtitle("Plot 3: Threshold and Accumulator model predictions and data - log scale")

```
**Plot 1**
This plots looks at lateral position at steering onset directly from the data for each heading condition.

**Plot 2**
Plot 2 plots Threshold and Accumulator lateral position predictions at steering onset, alongside actual lateral position at steering onset from the data. The Accumulator shows a non-linear increasing relationship between lateral position and heading. Conversely the Threshold model shows a relatively linear increase in lateral position as heading increases. In both of these models, the increase in lateral position is small as heading increases. 

The data appears to be slightly more in line with the Threshold model than the Accumulator.

The Threshold model shows a slight increase in lateral position as heading increases, however it is much less obvious than the Acccumulator (as would be expected). Under a real Threshold model, a lack of a flat line could be to do with slower control error development increasing the likelihood that a random noise fluncutation will exceed the threshold. This means a control action could be initiated sooner (and thus at a smaller lateral position from the line) which explain the Threshold model predicitions here.

The data also shows an increase in lateral position as heading increases. However because of the size the predicted values for the Accumulator model, it is hard to compare these value.

```{r comparing model predicitions for reaction times against heading/error rate}

prediction_thresh <- predict(thresh)
prediction_acc <- predict(acc)

modellingdata$prediction_thresh <- prediction_thresh
modellingdata$prediction_acc <- prediction_acc

ggplot(modellingdata, aes(x = heading, y = prediction_thresh)) +
  geom_line(aes(group = pNum)) +
  theme_gray()

ggplot(modellingdata, aes(x = heading, y = prediction_acc)) +
  geom_line(aes(group = pNum)) +
  theme_gray()

ggplot(modellingdata, aes(x = heading, y = FirstSteeringTime)) +
  geom_line(aes(group = pNum)) +
  theme_gray()



```

