---
title: "PracticeAnalysisCode"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

**Below is rough coding work for analysus script**                    

First attempt at tryign to select first SWA value above the deadzone threshold.

```{r first attempt at trying to select first SWA value}

pilot_clean <- subset(data, select = c(ppid, heading, cameraoffset, trialn, timestamp, World_x, World_z, WorldYaw, SWA, YawRate_seconds)) # selects important data columns

View(pilot_clean)
for (column_index in 9){
  v = pilot_clean[ ,column_index]}

time = pilot_clean$timestamp
swa = pilot_clean$SWA
FirstSWAction = swa > SWUpperThres | swa < SWLowerThres # returns a variable for trues and falses


for (i in length(FirstSWAction)){ # for the length of the FirstSWAction variable
  
}
  if (FirstSWAction == TRUE){ #if FirstSWAction is true
  a = data.frame(c(FirstSWAction[i], pilot_clean[FirstSWAction[i],  pilot_clean$timestamp]))} # create a dataframe a, containing the FirstSWAction true value and the timestamp in the corresponding row
```


Long-winded way of obtaining the first SWA value that is above threshold for each trial. Ends up with generating a one row data frame with trial number, SWA value, timestamp and heading. Ideally I would like to loop this and then load each trial into a dataframe.

```{r long-winded way}
library(ggplot2)
library(dplyr)

empty <- data.frame(numeric(22), numeric(22), numeric(22), numeric(22), numeric(22))
# above is an empty data frame to load the clean trial data into (potentially)

pilot_clean <- subset(workingdata, select = c(ppid, heading, cameraoffset, trialn, timestamp, World_x, World_z, WorldYaw, SWA, YawRate_seconds)) # selects important data columns

View(pilot_clean)


pilot_clean_2 <- pilot_clean %>%
  filter(trialn == 2) %>% # filter data within trial 2
  group_by(heading) %>% # group by the heading
  mutate(deadzone1 = abs(SWA) < 0.05, # calculate absolute SWA for values under 0.05
         deadzone0 = lag(deadzone1)) %>% # generates lagged version of time series
  filter(!deadzone1 & (deadzone0 | is.na(deadzone0))) %>% # filter SWA that is not in deadzone1, but is with deadzone0 
  select(heading, timestamp, trialn, SWA) # select relevant data columns
  
View(pilot_clean_2)

pilot_trial_2 <- data.frame(head(pilot_clean_2,1)) # select top value of 

View(pilot_trial_2)

# Above gives me the timestamp of the first SWA over threshold for trial 2. What I now need to do is to repeat this, perhaps in a loop, and then add these values one by one into my empty dataframe.

# I also need to work out how to manipulate timestamp so each trial is within 2.5 seconds, as the trial was...



# SWA_timestamp <- ggplot(data = pilot_clean, aes(x = timestamp, y = SWA, color = heading)) +
  #geom_line() # plots steering angle difference across the experiment
#SWA_timestamp


```

Similar to code above except this grabs multiple SWA values that are above the threshold for each trial - I only want the first steering action above threshold.

```{r obtaining first steering movement and corresponding timestamp}
library(dplyr)
pilot_clean <- subset(Pilot, select = c(ppid, heading, cameraoffset, trialn, timestamp, World_x, World_z, WorldYaw, SWA, YawRate_seconds)) # selects important data columns

View(pilot_clean)
pilot_clean %>% 
  group_by(heading) %>% 
  mutate(deadzone1 = abs(SWA) < 0.05, 
         deadzone0 = lag(deadzone1)) %>% 
  filter(!deadzone1 & (deadzone0 | is.na(deadzone0))) %>% 
  select(heading, timestamp, trialn, SWA) -> pilot_clean_out

View(pilot_clean_out)
```

Development of code above, aiming to select only the first SWA value above the threshold for each trial. This is not successful.

```{r obtaining first steering movement and corresponding timestamp - development}

library(dplyr)

pilot_clean <- subset(Pilot, select = c(ppid, heading, cameraoffset, trialn, timestamp, World_x, World_z, WorldYaw, SWA, YawRate_seconds)) # selects important data columns

View(pilot_clean)

count = 0;
int = 1:22; # number of trials
for (int in pilot_clean$trialn){ # for the different number of trials in trial column
    pilot_clean %>% 
      group_by(heading) %>%
      group_by(trialn) %>%
      mutate(deadzone1 = abs(SWA) < 0.05, # calculate absolute SWA for values under 0.05
         deadzone0 = lag(deadzone1)) %>% # generates lagged version of time series
      filter(!deadzone1 & (deadzone0 | is.na(deadzone0))) %>% # filter SWA that is not in deadzone1, 
      select(heading, timestamp, trialn, SWA) -> pilot_clean_out
  count = count + 1;
  if (count == 22){
    break
  }
}

View(pilot_clean_out)
```

Attempting to calculate trial time

```{r trying to calculate trial time}

library(dplyr)
pilot_clean <- subset(Pilot, select = c(ppid, heading, cameraoffset, trialn, timestamp, World_x, World_z, WorldYaw, SWA, YawRate_seconds)) # selects important data columns

View(pilot_clean)

split_trials <- split(pilot_clean, pilot_clean$trialn) # splits pilot by trial in a list

tail(split_trails[[1]][5], n = 1) - head(split_trails[[1]][5], n = 1) # this then calculates the first the trial time for trail 1
tail(split_trials[[2]][5], n = 1) - head(split_trials[[2]][5], n = 1) # and the same for trail 2

#However this just gives me a trial for the overall trial - not very useful

#I would need to find first timestamp where SWA was above threshold, select that and then subtract that from the first timestamp of the trial to generate how long it took for ppts to make first steering correction
                       

    #i <- data[data$timestamp,] # find all observations that exceed threshold
    #return(tail(i, n=1) - head(i, n=1)) # return only the first match

# pilot_clean_new <- do.call(rbind.data.frame, pilot_clean_new)

# View(pilot_clean_new)
                             
```
