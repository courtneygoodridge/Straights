---
title: "AnalysisRUpperLowerThreshold"
output: html_document
---

```{r setup, include=FALSE}
# chooseCRANmirror(graphics=FALSE, ind=1) # uncomment for knitting
# rm(list = ls()) # clear workspace
knitr::opts_chunk$set(echo = TRUE)
install.packages(ggplot2) # for plots
install.packages(dplyr) # for manipulating data frames
install.packages(tidyr) # for tidying data (uniting columns)
install.packages(TTR) # for smoothing data with mean of observations
install.packages(zoo) # package for rolling mean (rollmean function)
install.packages(skimr) # generates summary of data
install.packages(car) # to perform levenes and anova
install.packages(apaTables) # to create apa table
install.packages(WRS2) # for non-parametric anova
install.packages(compute.es) # for ancova type 3 method
install.packages(multcomp) # post hoc for type 3 method ancova
install.packages(lmPerm) # non-parametric ancova
install.packages(e1071) # for calculating skewness
install.packages(ggpubr) # for interactions plots and boxplots
install.packages(effsize) # for calculating effect sizes
install.packages(gganimate) # animate plots
install.packages(gifski) # animate plots
install.packages(png)
install.packages(transformr)
install.packages(signal) # package needed for sgolayfilt function for steering magnitude 
install.packages(conflicted) # heloful package to show when packages have conflicted functions # conflict_prefer("filter", "dplyr") means filter function from dplyr is prioritised



# install.packages(matlabr)
# install.packages(magrittr)

# full datasets
# set working directory on pffice laptop
setwd("C:/Users/pscmgo/OneDrive for Business/PhD/Project/Experiment_Code/Straights/Full_Data") 
# setwd("C:/Users/pscmgo/OneDrive for Business/PhD/Project/Experiment_Code/Straights/test_example/Full_Data") 

# set working directory on personal laptop
# setwd("C:/Users/Courtney/Documents/PhD/Project/Experiment_code/Straights/Full_Data")
# setwd("C:/Users/Courtney/Documents/PhD/Project/Experiment_code/Straights/test_example/Full_Data")
temp = list.files(pattern = c("BenLui17_")) # list all CSV files in the directory
myfiles = lapply(temp, read.csv) # read these CSV in the directory
workingdata <- do.call(rbind.data.frame, myfiles) # convert and combine the CSV files into dataframe


# pilot dataset
# setwd("M:/PhD/Project/Experiment_Code/Straights/Pilot")
# file_names <- dir("M:/PhD/Project/Experiment_Code/Straights/Pilot") #where you have your files
# workingdata <- do.call(rbind, lapply(file_names, read.csv))

```

```{r demographic information}
library(dplyr)
library(tidyr)

# age

workingdata %>%
  summarise(mean(age), max(age), min(age), median(age), sd(age))

# driving license time

workingdata %>%
  summarise(mean(licenseTime), max(licenseTime), min(licenseTime), median(licenseTime), sd(licenseTime))

# gender split 

gender <- workingdata %>%
  group_by(pNum, gender) %>%
  summarise(count = n()) %>%
  ungroup()

female <- filter(gender, gender == 1) 
male <- filter(gender, gender == 2)

length(female$gender) / length(gender$gender) * 100 
length(male$gender) / length(gender$gender) * 100

```

```{r altering StraightVisible variable (for new experiment design)}
library(dplyr)
library(tidyr)

workingdata <- unite(workingdata, ppid_trialn, ppid, trialn, sep = "_") # create unique ppid_trialn ID

# sapply(workingdata, class) # identifies class of each column

workingdata$StraightVisible <- as.numeric(workingdata$StraightVisible) # changes factor to numeric, 1 = false, 2 = true

workingdata <- workingdata %>%
group_by(ppid_trialn) %>%
dplyr::filter(StraightVisible == 2) %>% # filter for only data where central line is visible
mutate(frame = row_number()) # create frame number column

```


```{r  thresholds, removing trials with dropped frames, calculating yaw rate change}
library(dplyr)
library(tidyr)
# library(TTR)
# library(hemm)
# library(searcher)
# library(skimr)
# init_hemm()

# change in steering 
# magnitudethreshold = 0.140
upperthreshold = 0.13 # 0.105 #  # upper threshold for consistent steering response
lowerthreshold = 0.05 # 0.001, 0.05 lower threshold for when response initiated - lowest of the IQRs for each mean YawRateChange condition

workingdata <- workingdata %>%
  mutate(YawRateChange = YawRate_seconds - c(0, YawRate_seconds[-length(YawRate_seconds)])) %>% # difference in yaw rate
  group_by(ppid_trialn) %>%
  mutate(frame = row_number()) %>%
  ungroup()

```


```{r anchoring timestamps at 2.5 seconds and calculating frames column}
library(dplyr)

workingdata <- workingdata %>%
  group_by(ppid_trialn) %>%
  mutate(anchored_timestamp = timestamp - min(timestamp)) %>%
  dplyr::filter(anchored_timestamp <= min(anchored_timestamp) + 2.5) %>% # add for seconds fro the original data 
  ungroup() # create anchored timestamp and then only select first 2.5 seconds of data for each each ppid_trialn (only interested in the first steering adjustment as this point)

```


```{r golay smoothing and inverting data}
library(dplyr)
library(tidyr)
library(signal)

# inverting yaw rate signal and collapsing heading conditions

negativetimecourse <- workingdata %>%
  dplyr::filter(heading < 0) %>%
  mutate(heading = abs(heading)) %>%
  mutate(YawRateChange = -(YawRateChange))

positivetimecourse <- workingdata %>%
  dplyr::filter(heading > 0) %>%
  mutate(heading = abs(heading)) %>%
  mutate(YawRateChange = YawRateChange)

zerotimecourse <- workingdata %>%
  dplyr::filter(heading == 0) %>%
  mutate(heading = abs(heading)) %>%
  mutate(YawRateChange = YawRateChange)

workingdata <- rbind(negativetimecourse, positivetimecourse, zerotimecourse)

rm(negativetimecourse, positivetimecourse, zerotimecourse)

# golay filter data

workingdata <- workingdata %>%
  group_by(ppid_trialn) %>%
  mutate(YawRateChange = sgolayfilt(YawRateChange, n = 11)) %>%
  ungroup()

```


```{r formulating response start magnitude data}
library(dplyr)
library(tidyr)

# code below is identical to the RT data selection - both trying to find the same thing (start of the response)
mag_response_start <- workingdata %>% 
dplyr::select(ppid_trialn, heading, frame, YawRateChange, anchored_timestamp, pNum) %>% 
group_by(ppid_trialn) %>%
  dplyr::filter(max(YawRateChange) > upperthreshold, min(YawRateChange) < lowerthreshold) %>% # filter lowest yaw rate change smaller than the lower theshold, # filter largest yaw rate change greater than the upper threshold
  slice(1:min(which(YawRateChange > upperthreshold, 1))) %>% # slice from the first yaw value, to the first yaw value above the upper thrshold
  slice(min(which(YawRateChange > lowerthreshold, 1))) %>% # slice the row at the minimum yaw rate above the lower threshold to get start of the response
  ungroup() %>%
  transmute(ppid_trialn, heading, StartFrame = frame, StartYaw = YawRateChange, FirstSteeringTime = anchored_timestamp, pNum = pNum) %>%
  # mutate(steering_zscore = scale(FirstSteeringTime)) %>%
  mutate(EarlyResponses = FirstSteeringTime <= 0.15)

# filters out early responses
mag_response_start <- mag_response_start %>%
  dplyr::filter(EarlyResponses == FALSE)

```


```{r formulating response peak magnitude data}
library(dplyr)
library(tidyr)

mag_response_peak <- workingdata %>%
dplyr::select(ppid_trialn, heading, frame, YawRateChange, anchored_timestamp, pNum) %>%
group_by(ppid_trialn) %>%
mutate(peakYaw = max(YawRateChange)) %>%
dplyr::filter(max(YawRateChange) > upperthreshold, min(YawRateChange) < lowerthreshold) %>% 
slice(1:max(which(YawRateChange > upperthreshold, 1))) %>%
slice(max(which(YawRateChange == peakYaw))) %>%
ungroup() %>%
transmute(ppid_trialn, heading, PeakFrame = frame, PeakYaw = YawRateChange, PeakSteeringTime = anchored_timestamp, pNum = pNum)

# merge response start and response peak dataframes
magnitudedata <- merge(mag_response_start, mag_response_peak, by = "ppid_trialn")

rm(mag_response_start, mag_response_peak)

magnitudedata$heading.y <- NULL # remove duplicate column
magnitudedata$pNum.y <- NULL # rmeove duplicate
# magnitudedata$block.y <- NULL


colnames(magnitudedata)[colnames(magnitudedata) == 'heading.x'] <- 'heading'
colnames(magnitudedata)[colnames(magnitudedata) == 'pNum.x'] <- 'pNum'
# colnames(magnitudedata)[colnames(magnitudedata) == 'block.x'] <- 'block'

# setwd("C:/Users/pscmgo/OneDrive for Business/PhD/Project/Experiment_Code/Straights") # set directory for data saving
# write.csv(magnitudedata, file = "magnitudedata.csv")

```

```{r selecting very start of the trial world_x, world_z and worldyaw}

# obtains starting coordinates for every trial
trialstartcoords <- workingdata %>%
  group_by(ppid_trialn) %>%
  slice(1) %>%
  ungroup() %>%
  transmute(ppid_trialn, StartWorld_x = World_x, StartWorld_z = World_z, StartWorldYaw = WorldYaw)

```


```{r calculating genuine responses, formulating threshold RT data}
# library(zoo)
library(dplyr)
library(tidyr)
# library(TTR)

workingdatathresholdUnsmooth <- workingdata %>%
  group_by(ppid_trialn) %>%
  dplyr::filter(max(YawRateChange) > upperthreshold, min(YawRateChange) < lowerthreshold) %>% # filter lowest yaw rate change smaller than the lower theshold, # filter largest yaw rate change greater than the upper threshold
  slice(1:min(which(YawRateChange > upperthreshold, 1))) %>% # slice from the first yaw value, to the first yaw value above the upper thrshold
  slice(min(which(YawRateChange > lowerthreshold, 1))) %>% # slice the row at the minimum yaw rate above the lower threshold to get start of the response
  ungroup() %>%
  transmute(ppid_trialn, heading, cameraoffset, SWAThres = SWA, FirstSteeringTime = anchored_timestamp, ThresWorld_x = World_x, ThresWorld_z = World_z, ThresWorldYaw = WorldYaw, ThresYawRate_seconds = YawRate_seconds,ThresYawRateChange = YawRateChange, pNum = pNum, gender = gender, age = age, licenseTime = licenseTime, contacts_glasses = contacts_glasses) %>% 
  mutate(EarlyResponses = FirstSteeringTime <= 0.15)
  
```

```{r merging data for start coords and RT coords}

lanepositiondata <- merge(trialstartcoords, workingdatathresholdUnsmooth, by = "ppid_trialn")

```


```{r number of trials per condition - overall and genuine resposnes}
library(dplyr)

# overall number of trials per condition

overalltrials <- workingdata %>%
  group_by(ppid_trialn) %>%
  summarise(HeadingCondition = head(heading, n = 1)) %>% # select first heading value for each trial
  ungroup() %>% 
  group_by(HeadingCondition) %>% # group the heading values
  summarise(OverallTrials = n()) %>% # calculate the number of each heading
  ungroup()

# number of trials that survive the thresholding mechanism

recordedresponses <- workingdatathresholdUnsmooth %>%
  group_by(heading) %>%
  summarise(FirstStageTrials = n())

# number of trials that survive the early response threshold

trueresponses <- workingdatathresholdUnsmooth %>%
  dplyr::filter(EarlyResponses == FALSE) %>%
  group_by(heading) %>%
  summarise(SecondStageTrials = n())

d <- cbind(overalltrials, recordedresponses$FirstStageTrials, trueresponses$SecondStageTrials)

colnames(d) <- c("heading", "OverallTrials", "RecordedResponses", "TrueResponses")

d %>%
  group_by(heading) %>%
  summarise(RecordedResponsesPer = (RecordedResponses / OverallTrials) * 100, TrueResponsesPer = (TrueResponses / OverallTrials) * 100)
  
```


```{r filtering TRUE timecourses}
library(dplyr)
library(tidyr)
library(ggplot2)

workingdatathresholdUnsmooth <- workingdatathresholdUnsmooth %>%
  dplyr::filter(EarlyResponses == FALSE)

trueresponses <- dplyr::filter(workingdatathresholdUnsmooth, EarlyResponses == FALSE) # filters true threshold responses
trueresponses <- trueresponses$ppid_trialn # selects ID tags of true responses
trueresponses <- as.vector(trueresponses) # creates ID vector for filtering 

trueworkingdata <- dplyr::filter(workingdata, ppid_trialn %in% trueresponses) # filter the IDs in the ID vector

###### facet wrapped plot for median AND mean value ######

ggplot(data = trueworkingdata, aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line(show.legend = FALSE) +
  geom_vline(data = workingdatathresholdUnsmooth %>%
               summarise(medianFirstSteeringTime = median(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = medianFirstSteeringTime), color = "red", linetype = "dashed") +
  geom_vline(data = workingdatathresholdUnsmooth %>%
               summarise(meanFirstSteeringTime = mean(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = meanFirstSteeringTime), color = "blue", linetype = "dashed") +
  facet_wrap( ~ heading) +
  scale_y_continuous(name="Yaw rate change", limits=c(-1, 2.5)) +
  scale_x_continuous(name="Timestamp (secs)", limits=c(0, 2.5))

```

```{r filter NON-responses}

'%!in%' <- function(x,y)!('%in%'(x,y)) # oppsite of %in%

responseid <- workingdatathresholdUnsmooth$ppid_trialn # gets IDs of responses
responseid <- as.vector(responseid) # convert IDs to vector
nonresponses <- dplyr::filter(workingdata, ppid_trialn %!in% responseid) # filter IDs that are not response IDs

nonresponses <- nonresponses %>%
  group_by(ppid_trialn) %>%
  mutate(resp = "lower", response_num = 1, FirstSteeringTime = 2.5) %>%
    slice(1) %>% # selects one row of each trial
  ungroup() 

a <- nonresponses %>%
  dplyr::select(ppid_trialn, heading, pNum, resp, response_num, FirstSteeringTime)

workingdatathresholdUnsmooth <- workingdatathresholdUnsmooth %>%
  group_by(ppid_trialn) %>%
  mutate(resp = "upper", response_num = 2)

b <- workingdatathresholdUnsmooth %>%
  dplyr::select(ppid_trialn, heading, pNum, resp, response_num, FirstSteeringTime)

# dat <- rbind(a, b) # WHY DON'T YOU FUCKING WORK!!!!!!!

ppid_trialn <- c(a$ppid_trialn, b$ppid_trialn)
heading <- c(a$heading, b$heading)
pNum <- c(a$pNum, b$pNum)
resp <- c(a$resp, b$resp)
response_num <- c(a$response_num, b$response_num)
FirstSteeringTime <- c(a$FirstSteeringTime, b$FirstSteeringTime)
# block <- c(a$block, b$block)

dat <- as.data.frame(cbind(ppid_trialn, heading, pNum, resp, response_num, FirstSteeringTime))

rm(ppid_trialn, heading, pNum, resp, response_num, FirstSteeringTime, nonresponses, responseid, a, b)

dat$FirstSteeringTime <- as.character(dat$FirstSteeringTime)
dat$FirstSteeringTime <- as.numeric(dat$FirstSteeringTime)

dat$response_num <- as.character(dat$response_num)
dat$response_num <- as.numeric(dat$response_num)


dat <- dat %>%
  dplyr::filter(FirstSteeringTime > 0.15) # filter trials that are within physiological plausible boundary

sapply(dat, class)

```

```{r data saving for Rachel}

# converting data types
dat$FirstSteeringTime <- as.character(dat$FirstSteeringTime)
dat$FirstSteeringTime <- as.numeric(dat$FirstSteeringTime)
# dat$trial_number <- as.numeric(dat$trial_number)

dat$response_num <- as.numeric(dat$response)-1 # makes no steer 0 and steer 1

# arranging data

subject8_block3 <- dat %>%
  dplyr::filter(FirstSteeringTime > 0.15) %>%
  arrange(trial_number) %>%
  select(trial_number, heading, response, response_num, FirstSteeringTime)

setwd("C:/Users/pscmgo/OneDrive for Business/PhD/Project/Experiment_Code/Straights") # set directory for data saving
write.csv(subject8_block3, file = "subject8_block3.csv")

```


```{r average timecourse magnitudes}
library(dplyr)
library(ggplot2)

avgtimecourse <- trueworkingdata %>%
  group_by(heading, frame) %>%
  summarise(meanYaw = mean(YawRateChange)) %>%
  mutate(heading_factor = as.factor(heading)) %>%
  mutate(timestamp = frame / 60)

ggplot(data = avgtimecourse, aes(x = timestamp, y = meanYaw, colour = heading_factor)) + 
  geom_line()

```

```{r magnituide of response across conditions}
library(dplyr)
library(ggplot2)

# calculates the yaw increase and time taken to reach peak response

magnitudedata <- magnitudedata %>%
  group_by(ppid_trialn) %>%
  mutate(YawIncrease = PeakYaw - StartYaw, TimeToPeak = PeakSteeringTime - FirstSteeringTime)

magnitudedata %>%
  group_by(heading) %>%
  summarise(meanincrease = mean(YawIncrease), meantime = mean(FirstSteeringTime))

```


```{r timecourse plotting of yaw rate change - UNSMOOTH}
library(ggplot2)
library(dplyr)
# library(gganimate)
# library(gifski)
# library(png)
# library(transformr)

############################################################### MEAN PLOTS ########################################################

######## 0 heading ##########

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == 0), aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line(show.legend = FALSE) +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == 0) %>%
               summarise(meanFirstSteeringTime = mean(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = meanFirstSteeringTime)) +
  ggtitle("0 heading - unsmoothed")

####### +0.5 heading #########

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == 0.5), aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line(show.legend = FALSE) +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == 0.5) %>%
               summarise(meanFirstSteeringTime = mean(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = meanFirstSteeringTime)) +
  ggtitle("0.5 heading - unsmoothed")

######## +1 heading ##########

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == 1), aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line(show.legend = FALSE) +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == 1) %>%
               summarise(meanFirstSteeringTime = mean(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = meanFirstSteeringTime)) +
  ggtitle("+1 heading - Unsmoothed")

######## +1.5 heading ########

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == 1.5), aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line(show.legend = FALSE) +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == 1.5) %>%
               summarise(meanFirstSteeringTime = mean(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = meanFirstSteeringTime)) +
  ggtitle("1.5 heading - unsmoothed")

######## +2 heading ##########

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == 2), aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line(show.legend = FALSE) +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == 2) %>%
               summarise(meanFirstSteeringTime = mean(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = meanFirstSteeringTime)) +
  ggtitle("+2 heading - unsmoothed")



################################################################## MEDIAN PLOTS ######################################################


######## 0 heading ##########

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == 0), aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line(show.legend = FALSE) +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == 0) %>%
               summarise(medianFirstSteeringTime = median(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = medianFirstSteeringTime)) +
  ggtitle("0 heading - unsmoothed")
               
######## 0.5 heading ##########

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == 0.5), aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line(show.legend = FALSE) +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == 0.5) %>%
               summarise(medianFirstSteeringTime = median(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = medianFirstSteeringTime)) +
  ggtitle("0.5 heading - unsmoothed")

######## 1 heading ##########

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == 1), aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line(show.legend = FALSE) +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == 1) %>%
               summarise(medianFirstSteeringTime = median(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = medianFirstSteeringTime)) +
  ggtitle("+1 heading - Unsmoothed")

######## 1.5 heading ##########

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == 1.5), aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line(show.legend = FALSE) +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == 1.5) %>%
               summarise(medianFirstSteeringTime = median(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = medianFirstSteeringTime)) +
  ggtitle("1.5 heading - unsmoothed")

######## 2 heading ##########

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == 2), aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line(show.legend = FALSE) +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == 2) %>%
               summarise(medianFirstSteeringTime = median(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = medianFirstSteeringTime)) +
  ggtitle("+2 heading - unsmoothed")

###### facet wrapped plot for median value ######

ggplot(data = workingdatatimecourseUnsmooth, aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line(show.legend = FALSE) +
  geom_vline(data = workingdatathresholdUnsmooth %>%
               summarise(medianFirstSteeringTime = median(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = medianFirstSteeringTime), color = "black", linetype = "dashed") +
  facet_wrap( ~ heading) +
  scale_y_continuous(name="Yaw rate change", limits=c(-1, 2.5)) +
  scale_x_continuous(name="Timestamp (secs)", limits=c(0, 2.5))

###### facet wrapped plot for median AND mean value ######

ggplot(data = workingdatatimecourseUnsmooth, aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line(show.legend = FALSE) +
  geom_vline(data = workingdatathresholdUnsmooth %>%
               summarise(medianFirstSteeringTime = median(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = medianFirstSteeringTime), color = "red", linetype = "dashed") +
  geom_vline(data = workingdatathresholdUnsmooth %>%
               summarise(meanFirstSteeringTime = mean(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = meanFirstSteeringTime), color = "blue", linetype = "dashed") +
  facet_wrap( ~ heading) +
  scale_y_continuous(name="Yaw rate change", limits=c(-1, 2.5)) +
  scale_x_continuous(name="Timestamp (secs)", limits=c(0, 2.5))
  
```


```{r timecourse plotting for individual trials - UNSMOOTH, fig.height = 18, fig.width = 26}
library(ggplot2)
library(dplyr)
library(conflicted)
conflict_prefer("filter", "dplyr")

#### 0 ########

ggplot(data = filter(trueworkingdata, heading == 0), aes(x = anchored_timestamp, y = YawRateChange)) +
  geom_line() +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == 0), aes(xintercept = FirstSteeringTime, color = EarlyResponses)) +
  facet_wrap( ~ ppid_trialn) +
  ggtitle("0 heading - unsmoothed")

##### +0.5 #####

ggplot(data = filter(trueworkingdata, heading == 0.5), aes(x = anchored_timestamp, y = YawRateChange)) +
  geom_line() +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == 0.5), aes(xintercept = FirstSteeringTime, color = EarlyResponses)) +
  facet_wrap( ~ ppid_trialn) +
  ggtitle("0.5 heading - unsmoothed")


###### +1 ######

ggplot(data = filter(trueworkingdata, heading == 1), aes(x = anchored_timestamp, y = YawRateChange)) +
  geom_line() +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == 1), aes(xintercept = FirstSteeringTime, color = EarlyResponses)) +
  facet_wrap( ~ ppid_trialn) +
  ggtitle("+1 heading - unsmoothed")

#### 1.5 ####

ggplot(data = filter(trueworkingdata, heading == 1.5), aes(x = anchored_timestamp, y = YawRateChange)) +
  geom_line() +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == 1.5), aes(xintercept = FirstSteeringTime, color = EarlyResponses)) +
  facet_wrap( ~ ppid_trialn) +
  ggtitle("+1.5 heading - unsmoothed")

##### +2 #####

ggplot(data = filter(trueworkingdata, heading == 2), aes(x = anchored_timestamp, y = YawRateChange)) +
  geom_line() +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == 2), aes(xintercept = FirstSteeringTime, color = EarlyResponses)) +
  facet_wrap( ~ ppid_trialn) +
  ggtitle("+2 heading - unsmoothed")

```


```{r boxplots for all angles}
library(dplyr)
library(ggplot2)

ggplot(data = workingdatathresholdUnsmooth, aes(factor(heading_collapsed), FirstSteeringTime)) +
  geom_violin(draw_quantiles = c(0.25, 0.5, 0.75)) +
  stat_summary(fun.y = mean, colour = "red", geom = "point") +
  xlab("Heading angle (degrees)") +
  ylab("Time until first steering correction (secs)")

# violin plot example -> kernal density estimation generates an idea of the distribution. Provides probability calculations for where sample population would sit. 

# middle line represents the median value with lower and upper hinges representing 25th and 75th percentiles

ggplot(data = workingdatathresholdUnsmooth, aes(as.factor(heading), FirstSteeringTime)) +
  geom_boxplot() +
  stat_summary(fun.y = mean, colour = "red", geom = "point") +
  # ggtitle("First steering time across heading angles: UNSMOOTH ALL RESPONSES") +
  xlab("Heading angle (degrees)") +
  ylab("Time until first steering correction (secs)")

ggplot(data = workingdatathresholdSmooth, aes(as.factor(heading), FirstSteeringTime)) +
  geom_boxplot() +
  # stat_summary(fun.y = mean, colour = "red", geom = "point") +
  ggtitle("First steering time across heading angles: SMOOTH ALL RESPONSES") +
  xlab("Heading angle (degrees)") +
  ylab("Time until first steering correction (s)")

##### BOXPLOTS WHERE RESPONSES ARE GENUINE AND NOT TOO LATE

ggplot(data = filter(workingdatathresholdUnsmooth, Genuine_Response == TRUE & EarlyResponses == FALSE), aes(as.factor(heading), FirstSteeringTime)) +
  geom_boxplot() +
  stat_summary(fun.y = mean, colour = "red", geom = "point") +
  xlab("Heading angle (degrees)") +
  ylab("First steering reacton time (s)") 

ggplot(data = filter(workingdatathresholdSmooth, Genuine_Response == TRUE & EarlyResponses == FALSE), aes(as.factor(heading), FirstSteeringTime)) +
  geom_boxplot() +
  # stat_summary(fun.y = mean, colour = "red", geom = "point") +
  ggtitle("First steering time across heading angles: SMOOTH GENUINE RESPONSES") +
  xlab("Heading angle (degrees)") +
  ylab("Time until first steering correction (s)")


  
```


```{r first steering time graphed example, fig.height = 7, fig.width = 15}
# fig.height = 18, fig.width = 26
library(dplyr)
library(ggplot2)

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == 2), aes(x = anchored_timestamp, y = YawRateChange)) +
  geom_line() +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == 2), aes(xintercept = FirstSteeringTime, color = EarlyResponses)) +
  facet_wrap( ~ ppid_trialn) +
  scale_y_continuous(limits = c(-0.60, 0.80)) +
  ggtitle("Visualisation of data pre-processing for +2 heading") +
  xlab("Timestamp (secs)") +
  ylab("Yaw Rate Change") +
  labs(color = "Early Responses") +
  theme(plot.title = element_text(size = 18),
    legend.title = element_text(size = 18), 
    legend.text = element_text(size = 18),
    axis.text.x = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    axis.title = element_text(size = 20))
```

```{r normality assumptions tests}
library(ggplot2)
library(dplyr)
library(car) # anova and levenes table
library(apaTables) # for apa tables
library(MBESS) # for apa tables
library(WRS2) # for non-parametric
library(e1071) # for skewness calculation

# calculates skewness for each condition
magnitudedata %>%
  group_by(heading) %>%
  summarise(skew = skewness(FirstSteeringTime))

# histogram with normality curves
ggplot(magnitudedata, aes(x = FirstSteeringTime)) +
  geom_histogram(aes(y = ..density..)) +
  stat_function(
		fun = dnorm, 
		args = with(magnitudedata, c(mean = mean(FirstSteeringTime), sd = sd(FirstSteeringTime)))
	) + 
  facet_wrap( ~ heading)

# shapiro-wilk test for each heading - significant means not normally distributed
magnitudedata2 <- dplyr::filter(magnitudedata, heading == 2)
shapiro.test(magnitudedata2$FirstSteeringTime)

# need to make grouping variable a factor for levene's test - doesn't assume normality so significant means data is not normal
workingdatathresholdUnsmooth$heading_fact<-as.factor(workingdatathresholdUnsmooth$heading)
workingdatathresholdUnsmooth$groupSign_fact<-as.factor(workingdatathresholdUnsmooth$groupSign)
workingdatathresholdUnsmooth$absHeading_fact<-as.factor(workingdatathresholdUnsmooth$absHeading)
leveneTest(FirstSteeringTime ~ heading_fact, data = workingdatathresholdUnsmooth)

```

```{r anova tests}
library(ggplot2)
library(dplyr)
library(car) # anova and levenes table
library(apaTables) # for apa tables
library(MBESS) # for apa tables
library(WRS2) # for non-parametric
library(ggpubr) # for interaction plots/boxplots
library(effsize) # for calculating effect sizes

# Anova style 1
Anova1 <- aov(FirstSteeringTime ~ heading_fact, data = workingdatathresholdUnsmooth)
summary(Anova1)

# Post-hoc tests (only to be used on anova1 type of anova)
resultTukey <-TukeyHSD(Anova1)
resultTukey

# Anova style 2 ( linear model)
Anova2 <- lm(FirstSteeringTime ~ heading_fact, data = workingdatathresholdSmooth)
summary(Anova2)

# Post hoc tests for style 2 (linear model)
posth = glht(Anova2, linfct = mcp(heading_fact = "Tukey"))  
summary(posth)

# creates nice table with effect size
apa.aov.table(Anova1, filename = "APA_Anova_Table.doc", table.number = 1)

####### NON-PARAMETRIC ######

# Anova for non-parametric (heteroscedastic one-way ANOVA for trimmed means). It uses a generalization of Welch's method.
t1way(FirstSteeringTime ~ heading_fact, data = workingdatathresholdSmooth)

# Anova for non-parametric (heteroscedastic one-way ANOVA for trimmed means) and bootstrapping
t1waybt(FirstSteeringTime ~ heading_fact, data = clean_smooth_data, nboot = 10000)

# Post hoc for non-parametric anova
lincon(FirstSteeringTime ~ heading_fact, data = clean_smooth_data) 

# Anova for non-parametric (using medians values)
med1way(FirstSteeringTime ~ heading_fact, data = workingdatathresholdSmooth, iter = 10000)

```

```{r two-way ANOVA plots and analysis}
library(car) # anova and levenes table
library(ggpubr) # for interaction plots/boxplots

# generates sign condition and absolute heading condition for a two-way ANOVA
workingdatathresholdUnsmooth <- workingdatathresholdUnsmooth %>%
  mutate(groupSign = sign(heading)) %>%
  mutate(absHeading = abs(heading)) 

# boxplots for two-way ANOVA
ggboxplot(workingdatathresholdUnsmooth, x = "absHeading_fact", y = "FirstSteeringTime", color = "groupSign_fact",
          palette = c("#00AFBB", "#E7B800"))

# interaction plot for two-way ANOVA
ggline(workingdatathresholdUnsmooth, x = "absHeading_fact", y = "FirstSteeringTime", color = "groupSign_fact",
       add = c("mean_se", "dotplot"),
       palette = c("#00AFBB", "#E7B800"))

twowayAnova <- aov(FirstSteeringTime ~ absHeading_fact * groupSign_fact, data = workingdatathresholdUnsmooth)
summary(Anova1)

# Post-hoc tests (only to be used on anova1 type of anova)
resultTukey <-TukeyHSD(twowayAnova)
resultTukey

```


```{r ancova tests}
library(car)
library(compute.es) # ancova using type 3 method
library(multcomp) # post hoc for ancova type 3 method
library(lmPerm)
# allows you to partial out other observations within your data (i.e. initial SWA in my case)


# ancova using anova function but adding the covariates to your grouping variable - significant initialSWA would mean that the effect of the covariate on the main effects was significant
ancova1 <- aov(FirstSteeringTime ~ heading_fact + initialSWA, data = workingdatathresholdSmooth)
summary(ancova1)

resultTukey <-TukeyHSD(ancova1) # this doesn't work for some reason...
resultTukey

# ancova looking at first steering time whislt partialing out initialSWA - using linear model
lm_ancova2 <- lm(FirstSteeringTime ~ heading_fact + initialSWA, data = clean_smooth_data)
anova(lm_ancova2)

# ancova using type 3 method and linear model - significant initialSWA would mean that the effect of the covariate on the main effects was significant
ancova3 <- lm(FirstSteeringTime ~ heading_fact + initialSWA, contrasts = list(heading_fact = contr.sum), data = workingdatathresholdSmooth)
Anova(ancova3, type = "III")

# post hoc for ancova using linear model version
posth = glht(lm_ancova2, linfct = mcp(heading_fact = "Tukey"))  
summary(posth)

##### NON-PARAMETRIC #####

nonpara_ancova <- aovp(FirstSteeringTime ~ heading_fact + initialSWA, data = workingdatathresholdSmooth)
summary(nonpara_ancova)

resultTukey <-TukeyHSD(nonpara_ancova)
resultTukey


```

```{r loading magnitude data from matlab}
setwd("M:/PhD/Project/Experiment_Code/Straights") # set working directory
# setwd("C:/Users/Courtney/Documents/PhD/Project/Experiment_code/Straights")
magnitude <- read.csv("magnitudedata.csv", header = FALSE)

names(data) <- c("heading", "responseStart", "responsePeak", "responseEnd", "YawRateChangeChange", "YawRateChangeTime")

```
