---
title: "AnalysisRUpperLowerThreshold"
output: html_document
---

```{r setup, include=FALSE}
# chooseCRANmirror(graphics=FALSE, ind=1) # uncomment for knitting
# rm(list = ls()) # clear workspace
knitr::opts_chunk$set(echo = TRUE)
install.packages(ggplot2) # for plots
install.packages(dplyr) # for manipulating data frames
install.packages(tidyr) # for tidying data (uniting columns)
install.packages(TTR) # for smoothing data with mean of observations
install.packages(zoo) # package for rolling mean
install.packages(skimr) # generates summary of data
install.packages(car) # to perform levenes and anova
install.packages(apaTables) # to create apa table
install.packages(WRS2) # for non-parametric anova
install.packages(compute.es) # for ancova type 3 method
install.packages(multcomp) # post hoc for type 3 method ancova
install.packages(lmPerm) # non-parametric ancova
install.packages(e1071) # for calculating skewness
# install.packages(matlabr)
# install.packages("magrittr")

setwd("M:/PhD/Project/Experiment_Code/Straights") # set working directory
# setwd("C:/Users/Courtney/Documents/PhD/Project/Experiment_code/Straights")

temp = list.files(pattern = c("BenLui17_t3", "*.csv")) # list all CSV files in the directory
myfiles = lapply(temp, read.csv) # read these CSV in the directory
workingdata <- do.call(rbind.data.frame, myfiles) # convert and combine the CSV files into dataframe
```

```{r altering StraightVisible variable (for new experiment design)}
library(dplyr)
library(tidyr)

workingdata <- unite(workingdata, ppid_trialn, ppid, trialn, sep = "_") # create unique ppid_trialn ID

# sapply(workingdata, class) # identifies class of each column

workingdata$StraightVisible <- as.numeric(workingdata$StraightVisible) # changes factor to numeric, 1 = false, 2 = true

workingdata <- workingdata %>%
group_by(ppid_trialn) %>%
filter(StraightVisible == 2) %>% # filter for only data where central line is visible
mutate(frame = row_number()) # create frame number column

```

```{r  thresholds, removing trials with dropped frames, calculating yaw rate change}
library(dplyr)
library(tidyr)
library(TTR)
# library(hemm)
library(searcher)
library(skimr)
# init_hemm()

# change in steering 
magnitudethreshold = 0.140
upperthreshold = 0.105 # 0.2184 # upper threshold for consistent steering response
lowerthreshold = 0.005 # lower threshold for when response initiated - lowest of the IQRs for each mean YawRateChange condition

workingdata <- workingdata %>%
  mutate(YawRateChange = YawRate_seconds - c(0, YawRate_seconds[-length(YawRate_seconds)])) %>% #difference in yaw rate
  group_by(ppid_trialn) %>%
  mutate(frame = row_number()) %>%
  ungroup()

# workingdata$YawRateChange[workingdata$YawRateChange >= 0.73499999] <- 0 # removes random spikes

# colnames(workingdata)[colnames(workingdata)=="SWA"] <- "SWV"

# 
# workingdata <- workingdata %>%
#   mutate(SWA = SWV * 90)

# find out if frames have been dropped
# rows <- workingdatatimecourseUnsmooth %>%
#   group_by(ppid_trialn) %>%
#   summarise(rows = n())

# workingdata <- workingdata %>%
#   mutate(SWA = SWV * 90)



```

```{r Callum function fo r removing spikes - ask Callum about this}
# library(dplyr)
# 
# workingdata <- workingdata %>% 
#   group_by(ppid_trialn) %>% 
#   mutate(timestamp_diff = append(diff(timestamp),0))
# 
# #quick function for averaging out implausible fluctuations in yaw-rate due to variations in recorded timestamps.
# correctTimestamp <- 
#   function(x,y){ #x needs to be timestamp_diff, y needs to be yaw signal.
#     Tvec = which(x >.017) # Means dropped frames.
#     len = length(y)
#     for (i in 1:length(Tvec)){
#       p = Tvec[i]
#       t1 = x[p] #dropped frame.
#       t2 = x[p+1] #sometimes this is close to zero. If it is, average the two yaw rates. If it isn't, average the preceding and subsequent.
#       if (p+2 < len){
#         if (t2 < .015){ ##take the corresponding two datapoints in yaw rate and average
#           YR1 = y[p+1] 
#           YR2 = y[p+2]
#           YR_avg = (YR1+YR2) / 2
#           y[p+1] = YR_avg
#           y[p+2] = YR_avg  
#         } else { #means it is an isolated dropped frame. average before and after yaw-rates
#           YR1 = y[p]
#           YR2 = y[p+2]
#           YR_avg = (YR1+YR2) / 2
#           y[p+1] = YR_avg
#         }
#       }
#     }
#     return(y)
#   }
# 
# workingdata <- workingdata %>% 
#   group_by(ppid_trialn) %>% 
#   mutate(newYawRate = correctTimestamp(timestamp_diff,smoothedYawRate_seconds))
```

```{r anchoring timestamps at 4 seconds and calculating frames column}
library(dplyr)

workingdatatimecourseUnsmooth <- workingdata %>%
  group_by(ppid_trialn) %>%
  mutate(anchored_timestamp = timestamp - min(timestamp)) %>%
  filter(anchored_timestamp <= min(anchored_timestamp) + 2.5) %>% # add for seconds fro the original data 
  ungroup() # create anchored timestamp and then only select first 2.5 seconds of data for each each ppid_trialn (only interested in the first steering adjustment as this point)

# how many frames in each trial?
rows <- workingdata %>%
  group_by(ppid_trialn, heading) %>%
  summarise(rows = n())

View(rows)

rowsgenuine <- rows %>%
  filter(rows > 270)

```

```{r calculating genuine responses, formulating threshold data}
library(zoo)
library(dplyr)
library(tidyr)
library(TTR)

# Calculates peak magnitude and initial SWA for each trial
workingdatatimecourseUnsmooth <- workingdatatimecourseUnsmooth %>%
  group_by(ppid_trialn) %>%
  mutate(PeakMagnitude = max(abs(YawRateChange))) %>% # calculate peak yaw rate change
  ungroup()

workingdatathresholdUnsmooth <- workingdatatimecourseUnsmooth %>%
  group_by(ppid_trialn) %>%
  mutate(row_number(), Genuine_Response = if_else(PeakMagnitude >= magnitudethreshold, TRUE, FALSE)) %>%
  filter(max(abs(YawRateChange)) > upperthreshold, min(abs(YawRateChange)) < lowerthreshold) %>% # filter lowest yaw rate change smaller than the lower theshold, # filter largest yaw rate change greater than the upper threshold
  slice(1:min(which(abs(YawRateChange) > upperthreshold, 1))) %>% 
  slice(max(which(abs(YawRateChange) < lowerthreshold, 1))) %>% # which() returns rows where a condition is true. Taking the min() of all the rows that are greater than the criteria will return the first row where that is true.
  ungroup() %>%
  transmute(ppid_trialn, heading, cameraoffset, SWAThres = SWA, FirstSteeringTime = anchored_timestamp, ThresWorld_x = World_x, ThresWorld_z = World_z, ThresWorldYaw = WorldYaw, ThresYawRate_seconds = YawRate_seconds, ThresYawRateChange = YawRateChange, Genuine_Response = Genuine_Response, PeakMagnitude = PeakMagnitude) %>%
  mutate(EarlyResponses = FirstSteeringTime < mean(FirstSteeringTime) - sd(FirstSteeringTime))
# returns TRUE if response is less than 1 SD below mean first steering time
# guards against too fast responses
# mean(workingdatathresholdUnsmooth$FirstSteeringTime) - sd(workingdatathresholdUnsmooth$FirstSteeringTime) calculates the threshold for what is considered too fast i.e. below 0.25 seconds

# returns TRUE if response is more than 1 SD from zero -> mutate(EarlyResponse = if_else(FirstSteeringTime > 2*sd(mean(FirstSteeringTime)), TRUE, FALSE)) # label late responses

##################################### SMOOTHING DATA ###################################

# do I need to smooth SWA and calculate a new initial SWA variable for the smoothed data?

workingdatatimecourseSmooth <- workingdatatimecourseUnsmooth %>%
  mutate(smoothedYawRateChange = SMA(YawRateChange, n = 3)) # calculates moving average over the number of data points you specify

workingdatatimecourseSmooth[is.na(workingdatatimecourseSmooth)] <- 0 # set NA values to 0. This is because smoothing data in this way creates NA values if you don't have enough to average over. Unsure how else to get around this

# determine first time in each ppid, trialn group above threshold
workingdatathresholdSmooth <- workingdatatimecourseSmooth %>%
  group_by(ppid_trialn) %>%
  mutate(row_number(), Genuine_Response = if_else(PeakMagnitude >= magnitudethreshold, TRUE, FALSE)) %>%
  filter(max(abs(smoothedYawRateChange)) > upperthreshold, # filter largest yaw rate change greater than the upper threshold
         min(abs(smoothedYawRateChange)) < lowerthreshold) %>% # filter lowest yaw rate change smaller than the lower theshold
  slice(1:min(which(abs(smoothedYawRateChange) > upperthreshold, 1))) %>%
  slice(max(which(abs(smoothedYawRateChange) < lowerthreshold, 1))) %>% # which() returns rows where a condition is true. Taking the min() of all the rows that are greater than the criteria will return the first row where that is true.
  ungroup() %>%
  transmute(ppid_trialn, heading, cameraoffset, SWAThres = SWA, FirstSteeringTime = anchored_timestamp, ThresWorld_x = World_x, ThresWorld_z = World_z, ThresWorldYaw = WorldYaw, ThresYawRate_seconds = YawRate_seconds, ThresYawRateChange = smoothedYawRateChange, Genuine_Response = Genuine_Response, PeakMagnitude = PeakMagnitude) %>%
  mutate(EarlyResponses = FirstSteeringTime < mean(FirstSteeringTime) - sd(FirstSteeringTime))
# returns TRUE if response is less than 1 SD below mean first steering time
# guards against too fast responses
# mean(workingdatathresholdUnsmooth$FirstSteeringTime) - sd(workingdatathresholdUnsmooth$FirstSteeringTime) calculates the threshold for what is considered too fast i.e. below 0.25 seconds for t4 pilot dataset

# returns TRUE if response is more than 1 SD from zero -> mutate(ResponseTooLate = if_else(FirstSteeringTime > 2*sd(FirstSteeringTime), TRUE, FALSE)) # label late responses
 
##################################### SMOOTHING DATA ###################################

# Here SWA angle is redundent as it only takes the SWA for when the change in yaw rate is over the threshold... I'm interested in ThresYawRateChange (first change in yaw rate over threhsold) and FirstYawRateChangeTimeThres (first timestamp where yaw rate change is over threshold).

#Only thing extra would be to calculate frame rate (60 frames) (ask Richard), and then multiply by change in yaw rate to get yaw rate per second per second.

```


```{r checking initial SWA and repsonse time}
library(ggplot2)

# ggplot(workingdatathresholdUnsmooth, aes(x = absInitialSWA, y = FirstSteeringTime, color = as.factor(heading))) +
#   geom_point() +
#   geom_smooth(method = "lm", se = FALSE) +
#   ggtitle("Initial steering wheel angle and first steering response time") +
#   xlab("Initial steering wheel angle (degrees)") +
#   ylab("First steering response time (seconds)") +
#   labs(color = "Heading")
# 
# ggplot(filter(workingdatathresholdUnsmooth, heading == 0), aes(x = absInitialSWA, y = FirstSteeringTime, color = as.factor(heading))) +
#   geom_point() +
#   geom_smooth(method = "lm", se = FALSE) +
#   ggtitle("Initial steering wheel angle and first steering response time for 0 heading") +
#   xlab("Initial steering wheel angle (degrees)") +
#   ylab("First steering response time (seconds)") +
#   labs(color = "Heading")

```
Ths plot shows that for 0 heading conditions, alongside conditions that are close to zero, variations in the initial steering wheel angle generate more varied responses in first steering time. This could be due to the trajectory "bleed over" making it much harder for the participant to judge the error, or whether there is error at all. Larger headings may eradicate this phenomenon as the increased error signal overides any trajecoryt bleed over caused from previous trials.

```{r timecourse plotting of yaw rate change}
library(ggplot2)
library(dplyr)

# workingdatathresholdUnsmooth <- workingdatathresholdUnsmooth %>%
#   filter(Genuine_Response == TRUE & LateResponse == FALSE)
# 
# workingdatathresholdSmooth <- workingdatathresholdSmooth %>%
#   filter(Genuine_Response == TRUE & LateResponse == FALSE)


######## -2 heading ##########

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == -2), aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line() +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == -2) %>%
               summarise(meanFirstSteeringTime = mean(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = meanFirstSteeringTime)) +
  ggtitle("-2 heading - unsmoothed") +
  scale_y_continuous(limits = c(-0.50, 0.75))

# ggplot(data = filter(workingdatatimecourseSmooth, heading == -2), aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
#   geom_line() +
#   geom_vline(data = filter(workingdatathresholdSmooth, heading == -2) %>%
#                summarise(meanFirstSteeringTime = mean(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = meanFirstSteeringTime)) +
#   ggtitle("-2 heading - smoothed") +
#   scale_y_continuous(limits = c(-0.50, 0.75))

<<<<<<< HEAD
######## -1.5 ###########

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == -1.5), aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line() +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == -2) %>%
               summarise(meanFirstSteeringTime = mean(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = meanFirstSteeringTime)) +
  ggtitle("-1.5 heading - smoothed") +
=======
####### -1.5 heading #########

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == -1.5), aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line() +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == -1.5) %>%
               summarise(meanFirstSteeringTime = mean(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = meanFirstSteeringTime)) +
  ggtitle("-1.5 heading - unsmoothed") +
>>>>>>> 6627d753e0be3582f05ee3bdc8567fffe9058c29
  scale_y_continuous(limits = c(-0.50, 0.75))

######## -1 heading ##########

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == -1), aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line() +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == -1) %>%
               summarise(meanFirstSteeringTime = mean(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = meanFirstSteeringTime)) +
  ggtitle("-1 heading - unsmoothed") +
  scale_y_continuous(limits = c(-0.50, 0.75))

# ggplot(data = filter(workingdatatimecourseSmooth, heading == -1), aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
#   geom_line() +
#   geom_vline(data = filter(workingdatathresholdSmooth, heading == -1) %>%
#                summarise(meanFirstSteeringTime = mean(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = meanFirstSteeringTime)) +
#   ggtitle("-1 heading - smoothed") +
#   scale_y_continuous(limits = c(-0.50, 0.75))

<<<<<<< HEAD
######## -0.5 ###########

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == -0.5), aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line() +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == -2) %>%
               summarise(meanFirstSteeringTime = mean(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = meanFirstSteeringTime)) +
  ggtitle("0.5 heading - smoothed") +
=======
####### 0.5 heading #########

ggplot(data = filter(workingdatatimecourseSmooth, heading == -0.5), aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line() +
  geom_vline(data = filter(workingdatathresholdSmooth, heading == -0.5) %>%
               summarise(meanFirstSteeringTime = mean(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = meanFirstSteeringTime)) +
  ggtitle("-0.5 heading - smoothed") +
>>>>>>> 6627d753e0be3582f05ee3bdc8567fffe9058c29
  scale_y_continuous(limits = c(-0.50, 0.75))


######## 0 heading ##########

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == 0), aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line() +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == 0) %>%
               summarise(meanFirstSteeringTime = mean(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = meanFirstSteeringTime)) +
  ggtitle("0 heading - unsmoothed") +
  scale_y_continuous(limits = c(-0.50, 0.75))

# ggplot(data = filter(workingdatatimecourseSmooth, heading == 0), aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
#   geom_line() +
#   geom_vline(data = filter(workingdatathresholdSmooth, heading == 0) %>%
#                summarise(meanFirstSteeringTime = mean(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = meanFirstSteeringTime)) +
#   ggtitle("0 heading - smoothed") +
#   scale_y_continuous(limits = c(-0.50, 0.75))

<<<<<<< HEAD
######## 0.5 ###########

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == 0.5), aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line() +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == -2) %>%
=======
####### +0.5 heading #########

ggplot(data = filter(workingdatatimecourseSmooth, heading == 0.5), aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line() +
  geom_vline(data = filter(workingdatathresholdSmooth, heading == 0.5) %>%
>>>>>>> 6627d753e0be3582f05ee3bdc8567fffe9058c29
               summarise(meanFirstSteeringTime = mean(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = meanFirstSteeringTime)) +
  ggtitle("0.5 heading - smoothed") +
  scale_y_continuous(limits = c(-0.50, 0.75))

######## +1 heading ##########

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == 1), aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line() +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == 1) %>%
               summarise(meanFirstSteeringTime = mean(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = meanFirstSteeringTime)) +
  ggtitle("+1 heading - unsmoothed") +
  scale_y_continuous(limits = c(-0.50, 0.75))

# ggplot(data = filter(workingdatatimecourseSmooth, heading == 1), aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
#   geom_line() +
#   geom_vline(data = filter(workingdatathresholdSmooth, heading == 1) %>%
#                summarise(meanFirstSteeringTime = mean(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = meanFirstSteeringTime)) +
#   ggtitle("+1 heading - smoothed") +
#   scale_y_continuous(limits = c(-0.50, 0.75))

<<<<<<< HEAD
######## 1.5 ###########

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == 1.5), aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line() +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == -2) %>%
               summarise(meanFirstSteeringTime = mean(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = meanFirstSteeringTime)) +
  ggtitle("-1.5 heading - smoothed") +
=======
######## +1.5 heading ########

ggplot(data = filter(workingdatatimecourseSmooth, heading == 1.5), aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line() +
  geom_vline(data = filter(workingdatathresholdSmooth, heading == 1.5) %>%
               summarise(meanFirstSteeringTime = mean(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = meanFirstSteeringTime)) +
  ggtitle("1.5 heading - smoothed") +
>>>>>>> 6627d753e0be3582f05ee3bdc8567fffe9058c29
  scale_y_continuous(limits = c(-0.50, 0.75))


######## +2 heading ##########

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == 2), aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
  geom_line() +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == 2) %>%
               summarise(meanFirstSteeringTime = mean(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = meanFirstSteeringTime)) +
  ggtitle("+2 heading - unsmoothed") +
  scale_y_continuous(limits = c(-0.50, 0.75))

# ggplot(data = filter(workingdatatimecourseSmooth, heading == 2), aes(x = anchored_timestamp, y = YawRateChange, colour = ppid_trialn)) +
#   geom_line() +
#   geom_vline(data = filter(workingdatathresholdSmooth, heading == 2) %>%
#                summarise(meanFirstSteeringTime = mean(FirstSteeringTime, na.rm = TRUE)), aes(xintercept = meanFirstSteeringTime)) +
#   ggtitle("+2 heading - smoothed") +
#   scale_y_continuous(limits = c(-0.50, 0.75))

```


```{r genuine repsonse numbers}
library(dplyr)

workingdatathresholdUnsmooth %>%
  filter(ResponseTooLate == TRUE) %>%
  group_by(heading) %>%
  summarise(NumberOfLateAndEarlyRespones = n())

workingdatathresholdUnsmooth %>%
  filter(Genuine_Response == FALSE) %>%
  group_by(heading) %>%
  summarise(NumberOfNotGenuineResponses = n())

genuine <- workingdatathresholdSmooth %>%
  filter(Genuine_Response == TRUE & LateResponse == FALSE) %>%
  group_by(heading) %>%
  summarise(trials = n()) %>%
  ungroup()

overall <- workingdatathresholdSmooth %>%
  summarise(trials = n())

# percentage of trials kept after removing non-genuine responses
heading <- c('-2', '-1.5', '-1', '-0.5', '0.5', '1', '+1.5', '+2')
percentagetrialskept <- (genuine$trials/overall$trials * 100)
per <- data.frame(heading, percentagetrialskept)
View(per)


```


```{r timecourse plotting for individual trials}
library(ggplot2)
library(dplyr)

##### -2 ######

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == -2), aes(x = anchored_timestamp, y = YawRateChange)) +
  geom_line() +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == -2), aes(xintercept = FirstSteeringTime, color = Genuine_Response)) +
  facet_wrap( ~ ppid_trialn) +
  scale_y_continuous(limits = c(-0.60, 0.80)) +
  ggtitle("-2 heading - unsmoothed")

# ggplot(data = filter(workingdatatimecourseSmooth, heading == -2), aes(x = anchored_timestamp, y = smoothedYawRateChange)) +
#   geom_line() +
#   geom_vline(data = filter(workingdatathresholdSmooth, heading == -2), aes(xintercept = FirstSteeringTime, color = Genuine_Response)) +
#   facet_wrap( ~ ppid_trialn) +
#   scale_y_continuous(limits = c(-0.60, 0.80)) +
#   ggtitle("-2 heading - smoothed")

##### -1.5 #####

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == -1.5), aes(x = anchored_timestamp, y = YawRateChange)) +
  geom_line() +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == -1.5), aes(xintercept = FirstSteeringTime, color = Genuine_Response)) +
  facet_wrap( ~ ppid_trialn) +
  scale_y_continuous(limits = c(-0.60, 0.80)) +
  ggtitle("-2 heading - unsmoothed")

#### -1.5 #####

ggplot(data = filter(workingdatatimecourseSmooth, heading == -1.5), aes(x = anchored_timestamp, y = YawRateChange)) +
  geom_line() +
  geom_vline(data = filter(workingdatathresholdSmooth, heading == -1.5), aes(xintercept = FirstSteeringTime, color = Genuine_Response)) +
  facet_wrap( ~ ppid_trialn) +
  scale_y_continuous(limits = c(-0.60, 0.80)) +
  ggtitle("-1.5 heading - smoothed")

##### -1 ######

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == -1), aes(x = anchored_timestamp, y = YawRateChange)) +
  geom_line() +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == -1), aes(xintercept = FirstSteeringTime, color = Genuine_Response)) +
  facet_wrap( ~ ppid_trialn) +
  scale_y_continuous(limits = c(-0.60, 0.80)) +
  ggtitle("-1 heading - unsmoothed")

# ggplot(data = filter(workingdatatimecourseSmooth, heading == -1), aes(x = anchored_timestamp, y = smoothedYawRateChange)) +
#   geom_line() +
#   geom_vline(data = filter(workingdatathresholdSmooth, heading == -1), aes(xintercept = FirstSteeringTime, color = Genuine_Response)) +
#   facet_wrap( ~ ppid_trialn) +
#   scale_y_continuous(limits = c(-0.60, 0.80)) +
#   ggtitle("-1 heading - smoothed")

#### 0.5 ######

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == -0.5), aes(x = anchored_timestamp, y = YawRateChange)) +
  geom_line() +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == -0.5), aes(xintercept = FirstSteeringTime, color = Genuine_Response)) +
  facet_wrap( ~ ppid_trialn) +
  scale_y_continuous(limits = c(-0.60, 0.80)) +
  ggtitle("-0.5 heading - unsmoothed")

##### 0.5 #####

ggplot(data = filter(workingdatatimecourseSmooth, heading == -0.5), aes(x = anchored_timestamp, y = YawRateChange)) +
  geom_line() +
  geom_vline(data = filter(workingdatathresholdSmooth, heading == -0.5), aes(xintercept = FirstSteeringTime, color = Genuine_Response)) +
  facet_wrap( ~ ppid_trialn) +
  scale_y_continuous(limits = c(-0.60, 0.80)) +
  ggtitle("-0.5 heading - smoothed")


#### 0 ########

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == 0), aes(x = anchored_timestamp, y = YawRateChange)) +
  geom_line() +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == 0), aes(xintercept = FirstSteeringTime, color = Genuine_Response)) +
  facet_wrap( ~ ppid_trialn) +
  scale_y_continuous(limits = c(-0.60, 0.80)) +
  ggtitle("0 heading - unsmoothed")

# ggplot(data = filter(workingdatatimecourseSmooth, heading == 0), aes(x = anchored_timestamp, y = smoothedYawRateChange)) +
#   geom_line() +
#   geom_vline(data = filter(workingdatathresholdSmooth, heading == 0), aes(xintercept = FirstSteeringTime, color = Genuine_Response)) +
#   facet_wrap( ~ ppid_trialn) +
#   scale_y_continuous(limits = c(-0.60, 0.80)) +
#   ggtitle("0 heading - smoothed")

##### 0.5 ######

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == 0.5), aes(x = anchored_timestamp, y = YawRateChange)) +
  geom_line() +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == 0.5), aes(xintercept = FirstSteeringTime, color = Genuine_Response)) +
  facet_wrap( ~ ppid_trialn) +
  scale_y_continuous(limits = c(-0.60, 0.80)) +
  ggtitle("0.5 heading - unsmoothed")

##### +0.5 #####

ggplot(data = filter(workingdatatimecourseSmooth, heading == 0.5), aes(x = anchored_timestamp, y = YawRateChange)) +
  geom_line() +
  geom_vline(data = filter(workingdatathresholdSmooth, heading == 0.5), aes(xintercept = FirstSteeringTime, color = Genuine_Response)) +
  facet_wrap( ~ ppid_trialn) +
  scale_y_continuous(limits = c(-0.60, 0.80)) +
  ggtitle("0.5 heading - smoothed")

###### +1 ######

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == 1), aes(x = anchored_timestamp, y = YawRateChange)) +
  geom_line() +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == 1), aes(xintercept = FirstSteeringTime, color = Genuine_Response)) +
  facet_wrap( ~ ppid_trialn) +
  scale_y_continuous(limits = c(-0.60, 0.80)) +
  ggtitle("+1 heading - unsmoothed")

# ggplot(data = filter(workingdatatimecourseSmooth, heading == 1), aes(x = anchored_timestamp, y = smoothedYawRateChange)) +
#   geom_line() +
#   geom_vline(data = filter(workingdatathresholdSmooth, heading == 1), aes(xintercept = FirstSteeringTime, color = Genuine_Response)) +
#   facet_wrap( ~ ppid_trialn) +
#   scale_y_continuous(limits = c(-0.60, 0.80)) +
#   ggtitle("+1 heading - smoothed")

#### 1.5 ####

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == 1.5), aes(x = anchored_timestamp, y = YawRateChange)) +
  geom_line() +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == 1.5), aes(xintercept = FirstSteeringTime, color = Genuine_Response)) +
  facet_wrap( ~ ppid_trialn) +
  scale_y_continuous(limits = c(-0.60, 0.80)) +
  ggtitle("-2 heading - unsmoothed")

##### 1.5 #####

ggplot(data = filter(workingdatatimecourseSmooth, heading == 1.5), aes(x = anchored_timestamp, y = YawRateChange)) +
  geom_line() +
  geom_vline(data = filter(workingdatathresholdSmooth, heading == 1.5), aes(xintercept = FirstSteeringTime, color = Genuine_Response)) +
  facet_wrap( ~ ppid_trialn) +
  scale_y_continuous(limits = c(-0.60, 0.80)) +
  ggtitle("+1.5 heading - smoothed")

##### +2 #####

ggplot(data = filter(workingdatatimecourseUnsmooth, heading == 2), aes(x = anchored_timestamp, y = YawRateChange)) +
  geom_line() +
  geom_vline(data = filter(workingdatathresholdUnsmooth, heading == 2), aes(xintercept = FirstSteeringTime, color = Genuine_Response)) +
  facet_wrap( ~ ppid_trialn) +
  scale_y_continuous(limits = c(-0.60, 0.80)) +
  ggtitle("+2 heading - unsmoothed")

# ggplot(data = filter(workingdatatimecourseSmooth, heading == 2), aes(x = anchored_timestamp, y = smoothedYawRateChange)) +
#   geom_line() +
#   geom_vline(data = filter(workingdatathresholdSmooth, heading == 2), aes(xintercept = FirstSteeringTime, color = Genuine_Response)) +
#   facet_wrap( ~ ppid_trialn) +
#   scale_y_continuous(limits = c(-0.60, 0.80)) +
#   ggtitle("+2 heading - smoothed")

```


```{r mean first steering adjustment}
library(dplyr)

workingdatathresholdUnsmooth %>%
  group_by(heading) %>%
  summarise(meanFirstSteeringTime = mean(FirstSteeringTime, na.rm = TRUE))

workingdatathresholdUnsmooth %>%
  filter(Genuine_Response == TRUE & LateResponse == FALSE) %>%
  group_by(heading) %>%
  summarise(meanFirstSteeringTimeTRUE = mean(FirstSteeringTime, na.rm = TRUE))

# workingdatathresholdSmooth %>%
#   group_by(heading) %>%
#   summarise(meanFirstSteeringTimeALLRESPONSES = mean(FirstSteeringTime, na.rm = TRUE))
# 
# workingdatathresholdSmooth %>%
#   filter(Genuine_Response == TRUE & LateResponse == FALSE) %>%
#   group_by(heading) %>%
#   summarise(meanFirstSteeringTimeGENUINERESPONSES = mean(FirstSteeringTime, na.rm = TRUE))

```

```{r normality assumptions tests}
library(ggplot2)
library(dplyr)
library(car) # anova and levenes table
library(apaTables) # for apa tables
library(MBESS) # for apa tables
library(WRS2) # for non-parametric
library(e1071) # for skewness calculation

# skim of the data
skim(clean_smooth_data)

# calculates skewness for each condition
workingdatathresholdUnsmooth %>%
  group_by(heading) %>%
  summarise(skew = skewness(FirstSteeringTime))

# histogram normality
ggplot(workingdatathresholdUnsmooth, aes(x = FirstSteeringTime)) +
  geom_histogram() +
  facet_wrap( ~ heading)

# shapiro-wilk test for each heading - significant means not normally distributed
workingdatathresholdUnsmooth2 <- filter(workingdatathresholdUnsmooth, heading == -0.5)
shapiro.test(workingdatathresholdUnsmooth2$FirstSteeringTime)

# need to make grouping variable a factor for levene's test - doesn't assume normality so significant means data is not normal
workingdatathresholdUnsmooth$heading_fact<-as.factor(workingdatathresholdUnsmooth$heading)
leveneTest(FirstSteeringTime ~ heading_fact, data = workingdatathresholdUnsmooth)

```


```{r anova tests}
library(ggplot2)
library(dplyr)
library(car) # anova and levenes table
library(apaTables) # for apa tables
library(MBESS) # for apa tables
library(WRS2) # for non-parametric

###### PARAMETRIC ######

# Anova style 1
Anova1 <- aov(FirstSteeringTime ~ heading_fact, data = workingdatathresholdUnsmooth)
summary(Anova1)

# Post-hoc tests (only to be used on anova1 type of anova)
resultTukey <-TukeyHSD(Anova1)
resultTukey

# Anova style 2 ( linear model)
Anova2 <- lm(FirstSteeringTime ~ heading_fact, data = workingdatathresholdSmooth)
summary(Anova2)

# Post hoc tests for style 2 (linear model)
posth = glht(Anova2, linfct = mcp(heading_fact = "Tukey"))  
summary(posth)

# creates nice table with effect size
apa.aov.table(Anova1, filename = "APA_Anova_Table.doc", table.number = 1)

####### NON-PARAMETRIC ######

# Anova for non-parametric (heteroscedastic one-way ANOVA for trimmed means). It uses a generalization of Welch's method.
t1way(FirstSteeringTime ~ heading_fact, data = workingdatathresholdSmooth)

# Anova for non-parametric (heteroscedastic one-way ANOVA for trimmed means) and bootstrapping
t1waybt(FirstSteeringTime ~ heading_fact, data = clean_smooth_data, nboot = 10000)

# Post hoc for non-parametric anova
lincon(FirstSteeringTime ~ heading_fact, data = clean_smooth_data) 

# Anova for non-parametric (using medians values)
med1way(FirstSteeringTime ~ heading_fact, data = workingdatathresholdSmooth, iter = 10000)

```

```{r ancova tests}
library(car)
library(compute.es) # ancova using type 3 method
library(multcomp) # post hoc for ancova type 3 method
library(lmPerm)
# allows you to partial out other observations within your data (i.e. initial SWA in my case)


# ancova using anova function but adding the covariates to your grouping variable - significant initialSWA would mean that the effect of the covariate on the main effects was significant
ancova1 <- aov(FirstSteeringTime ~ heading_fact + initialSWA, data = workingdatathresholdSmooth)
summary(ancova1)

resultTukey <-TukeyHSD(ancova1) # this doesn't work for some reason...
resultTukey

# ancova looking at first steering time whislt partialing out initialSWA - using linear model
lm_ancova2 <- lm(FirstSteeringTime ~ heading_fact + initialSWA, data = clean_smooth_data)
anova(lm_ancova2)

# ancova using type 3 method and linear model - significant initialSWA would mean that the effect of the covariate on the main effects was significant
ancova3 <- lm(FirstSteeringTime ~ heading_fact + initialSWA, contrasts = list(heading_fact = contr.sum), data = workingdatathresholdSmooth)
Anova(ancova3, type = "III")

# post hoc for ancova using linear model version
posth = glht(lm_ancova2, linfct = mcp(heading_fact = "Tukey"))  
summary(posth)

##### NON-PARAMETRIC #####

nonpara_ancova <- aovp(FirstSteeringTime ~ heading_fact + initialSWA, data = workingdatathresholdSmooth)
summary(nonpara_ancova)

resultTukey <-TukeyHSD(nonpara_ancova)
resultTukey


```


```{r boxplots for all angles}
library(dplyr)
library(ggplot2)

ggplot(data = workingdatathresholdUnsmooth, aes(as.factor(heading), FirstSteeringTime)) +
  geom_boxplot() +
  # stat_summary(fun.y = mean, colour = "red", geom = "point") +
  ggtitle("First steering time across heading angles: UNSMOOTH ALL RESPONSES") +
  xlab("Heading angle (degrees)") +
  ylab("Time until first steering correction (s)")

ggplot(data = workingdatathresholdSmooth, aes(as.factor(heading), FirstSteeringTime)) +
  geom_boxplot() +
  # stat_summary(fun.y = mean, colour = "red", geom = "point") +
  ggtitle("First steering time across heading angles: SMOOTH ALL RESPONSES") +
  xlab("Heading angle (degrees)") +
  ylab("Time until first steering correction (s)")

##### BOXPLOTS WHERE RESPONSES ARE GENUINE AND NOT TOO LATE

ggplot(data = filter(workingdatathresholdUnsmooth, Genuine_Response == TRUE & LateResponse == FALSE), aes(as.factor(heading), FirstSteeringTime)) +
  geom_boxplot() +
  # stat_summary(fun.y = mean, colour = "red", geom = "point") +
  ggtitle("First steering time across heading angles: UNSMOOTH GENUINE RESPONSES") +
  xlab("Heading angle (degrees)") +
  ylab("Time until first steering correction (s)") 

ggplot(data = filter(workingdatathresholdSmooth, Genuine_Response == TRUE & LateResponse == FALSE), aes(as.factor(heading), FirstSteeringTime)) +
  geom_boxplot() +
  # stat_summary(fun.y = mean, colour = "red", geom = "point") +
  ggtitle("First steering time across heading angles: SMOOTH GENUINE RESPONSES") +
  xlab("Heading angle (degrees)") +
  ylab("Time until first steering correction (s)") 


  
```


```{r averaging data and saving for matlab}
library(dplyr)

minus2 <- workingdatatimecourseUnsmooth %>% 
  filter(heading == -2) %>%
  group_by(frame) %>% 
  summarise(meanYawRateChange = mean(YawRateChange))

minus1 <- workingdatatimecourseUnsmooth %>% 
  filter(heading == -1) %>%
  group_by(frame) %>% 
  summarise(meanYawRateChange = mean(YawRateChange))

zero <- workingdatatimecourseUnsmooth %>% 
  filter(heading == 0) %>%
  group_by(frame) %>% 
  summarise(meanYawRateChange = mean(YawRateChange))

plus1 <- workingdatatimecourseUnsmooth %>% 
  filter(heading == 1) %>%
  group_by(frame) %>% 
  summarise(meanYawRateChange = mean(YawRateChange))

plus2 <- workingdatatimecourseUnsmooth %>% 
  filter(heading == 2) %>%
  group_by(frame) %>% 
  summarise(meanYawRateChange = mean(YawRateChange))

avgtimecourse <- data.frame(minus2 = numeric(n),
                           minus1 = numeric(n),
                           zero = numeric(n),
                           plus1 = numeric(n),
                           plus2 = numeric(n))

avgtimecourse$minus2 <- minus2$meanYawRateChange
avgtimecourse$minus1 <- minus1$meanYawRateChange
avgtimecourse$zero <- zero$meanYawRateChange
avgtimecourse$plus1 <- plus1$meanYawRateChange
avgtimecourse$plus2 <- plus2$meanYawRateChange

# Write CSV in R
write.csv(avgtimecourse, file = "avgtimecourse.csv")

# write.csv(avgtimecourse, file = "avgtimecourseGENUINE.csv")

```

