---
title: "Untitled"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r bin method from my example}
# converts first steering time from factor to numeric data type

# must convert to character first as factors are saved as integer codes which change your values when you convert using as.numeric first

dat$FirstSteeringTime <- as.character(dat$FirstSteeringTime)
dat$FirstSteeringTime <- as.numeric(dat$FirstSteeringTime)
dat$response_num <- as.integer(dat$response_num)

# creates "strength bins" with regard to stimuluis intensity, decimal places throw an error

heading0 <- dat %>%
  filter(heading == 0) %>%
  mutate(heading = 1)

heading0_5 <- dat %>%
  filter(heading == 0.5) %>%
  mutate(heading = 2)

heading1 <- dat %>%
  filter(heading == 1) %>%
  mutate(heading = 3)

heading1_5 <- dat %>%
  filter(heading == 1.5) %>%
  mutate(heading = 4)

heading2 <- dat %>%
  filter(heading == 2) %>%
  mutate(heading = 5)

dat2 <- rbind(heading0, heading0_5, heading1, heading1_5, heading2)

rm(heading0, heading0_5, heading1, heading1_5, heading2)

dat2$heading <- as.factor(dat2$heading)

```

```

```{r 1}

data("rr98")

rr98$instruction <- NULL

# try and implement strength bins into my own data...

#bins <- c(-0.5, 5.5, 10.5, 13.5, 16.5, 19.5, 25.5, 32.5) # seven bins like RR98
bins <- c(-0.5, 10.5, 13.5, 16.5, 19.5, 32.5)
rr98$strength_bin <- cut(rr98$strength, breaks = bins, include.lowest = TRUE)
levels(rr98$strength_bin) <- as.character(1:7)

# aggregate data for response probability plot:
agg_rr98_bin <- rr98 %>% 
  group_by(id, strength_bin) %>%
  summarise(n = n(), 
            dark = sum(response == "dark"),
            light = sum(response == "light")) %>%
  ungroup() %>%
  mutate(prop = map2(dark, n, ~ binom.confint(.x, .y, methods = "agresti-coull"))) %>% 
  unnest(prop)


knitr::kable(
  rr98 %>% group_by(id, strength_bin, response) %>%
    summarise(n = n()) %>%
    spread(strength_bin, n)
)
```

```{r 2}
d_nested <- rr98 %>% 
  group_by(id) %>% # we loop across both, id and instruction
  nest()
d_nested

```


```{r 3}

# objective function for diffusion with 1 a. loops over drift to assign drift rates to strength
objective_diffusion_separate <- function(pars, rt, response, drift, ...) {
  non_v_pars <- grep("^v", names(pars), invert = TRUE, value = TRUE)
  base_par <- length(non_v_pars)  # number of non-drift parameters
  densities <- vector("numeric", length(rt))
  for (i in seq_along(levels(drift))) {
    densities[drift == levels(drift)[i]] <- 
      ddiffusion(rt[drift == levels(drift)[i]], response=response[drift == levels(drift)[i]], 
                 a=pars["a"], t0=pars["t0"],  
                 sv=pars["sv"],
                 sz=if ("sz" %in% non_v_pars) pars["sz"] else 0.1,
                 z=if ("z" %in% non_v_pars) pars["z"]*pars["a"] else 0.5*pars["a"],
                 st0=if ("st0" %in% non_v_pars) pars["st0"] else 0, 
                 v=pars[base_par+i])
  }
  if (any(densities == 0)) return(1e6)
  return(-sum(log(densities)))
}
```


```{r }
# function that creates random start values, also 
get_start <- function(base_par, n_drift = 5) {
  start1 <- c(
    a = runif(1, 0.5, 3),
    a_1 = runif(1, 0.5, 3), 
    a_2 = runif(1, 0.5, 3),
    t0 = runif(1, 0, 0.5), 
    z = runif(1, 0.4, 0.6), 
    sz = runif(1, 0, 0.5),
    sv = runif(1, 0, 0.5),
    st0 = runif(1, 0, 0.5),
    d = rnorm(1, 0, 0.05)
  )
  start2 <- sort(rnorm(n_drift), decreasing = FALSE)
  names(start2) <- paste0("v_", seq_len(n_drift))
  c(start1[base_par], start2)
}



# function that tries different random start values until it works:
ensure_fit <- 
  function(data, start_function, objective_function, 
           base_pars, n_drift = 5, n_fits = 1, 
           lower = c(rep(0, length(base_pars)), -Inf,
                     rep(-Inf,length(start_function(base_pars))-length(base_pars)))) {
    best_fit <- list(objective = 1e+06)
  for (i in seq_len(n_fits)) {
    start_ll <- 1e+06
    #browser()
    while(start_ll == 1e+06) {
      start <- start_function(base_pars, n_drift=n_drift)
      start_ll <- objective_function(start, 
                                     rt = data$rt, response = data$response_num, 
                                     drift = factor(data$strength_bin, seq_len(n_drift)))
    }
    cat("\nstart fitting.\n") # just for information to see if it is stuck

    fit <- nlminb(start, objective_function, 
                  rt = data$rt, response = data$response_num, 
                  drift = factor(data$strength_bin, seq_len(n_drift)),
                  lower = lower)

    if (fit$objective < best_fit$objective) best_fit <- fit
  }
  out <- as.data.frame(t(unlist(best_fit[1:3])))
  colnames(out) <- sub("par.", "", colnames(out))
  out
}


```

```{r 5}

fit_diffusion <- d_nested %>% 
  mutate(fit = 
           map(data, 
               ~ensure_fit(data = ., start_function = get_start, 
                            objective_function = objective_diffusion_separate, 
                            base_pars = c("a", "t0", "sv", "sz", "z")))) %>% 
  unnest(fit)

```
