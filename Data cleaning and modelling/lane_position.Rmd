---
title: "lane_position"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load libraries}

library(dplyr)
library(tidyr)
library(ggplot2)

```

```{r load in full datasets}
# rm(list = ls()) 
# full datasets
# set working directory on office laptop
setwd("C:/Users/pscmgo/OneDrive for Business/PhD/Project/Experiment_Code/Straights/Full_Data") 

# working directory for personal laptop
# setwd("C:/Users/Courtney/Documents/PhD/Project/Experiment_code/Straights/Full_Data")

temp = list.files(pattern = c("BenLui17_")) # list all CSV files in the directory
myfiles = lapply(temp, read.csv) # read these CSV in the directory
workingdata <- do.call(rbind.data.frame, myfiles) # convert and combine the CSV files into dataframe

```


```{r computing triggered time and threshold (in metres)}

modellingdata <- modellingdata %>%
  group_by(pNum) %>%
  mutate(triggered_time = FirstSteeringTime - individual_intercept) %>%
  mutate(model_threshold = triggered_time / error_rate)

```

**Computing threshold value from threshold model**

We know that: 

RT = latency + threshold * error rate, so therefore

RT - latency = threshold * error rate

Threshold = (RT - latency) / error rate

Error rate = (RT - latency) / threshold

Latency = RT - threshold * error rate.

Subtracting the intercept value (latency) from the RT generates the triggered response time i.e. how long before subjects realised they needed to make a response. Some of these values are negative, suggested that the model is predicting latency values that are longer than what people are actually responding... on a qualitative level, this could indicate the model does not describe the data well.

```{r creating unique ID tag, selecting only when line is visible and differentiate yaw rate}

upperthreshold = 0.13
lowerthreshold = 0.05

workingdata <- unite(workingdata, ppid_trialn, ppid, trialn, sep = "_") # create unique ppid_trialn ID

workingdata$StraightVisible <- as.numeric(workingdata$StraightVisible) # changes factor to numeric, 1 = false, 2 = true

workingdata <- workingdata %>%
  group_by(ppid_trialn) %>%
  dplyr::filter(StraightVisible == 2) %>% # filter for only data where central line is visible
  mutate(frame = row_number()) # create frame number column


workingdata <- workingdata %>%
  mutate(YawRateChange = YawRate_seconds - c(0, YawRate_seconds[-length(YawRate_seconds)])) %>% # difference in yaw rate
  group_by(ppid_trialn) %>%
  mutate(frame = row_number()) %>%
  ungroup()

```


```{r collapsing across heading values}

negativetimecourse <- workingdata %>%
  dplyr::filter(heading < 0) %>%
  mutate(heading = abs(heading)) %>%
  mutate(YawRateChange = abs(YawRateChange))

positivetimecourse <- workingdata %>%
  dplyr::filter(heading > 0) %>%
  mutate(heading = abs(heading)) %>%
  mutate(YawRateChange = YawRateChange)
  
zerotimecourse <- workingdata %>%
  dplyr::filter(heading == 0) %>%
  mutate(heading = abs(heading)) 

workingdata <- rbind(negativetimecourse, positivetimecourse, zerotimecourse)

rm(negativetimecourse, positivetimecourse, zerotimecourse)


```

Collapsing across heading conditions

```{r selecting start thresh world yaw values}

# obtains starting coordinates for every trial
trialstartcoords <- workingdata %>%
  group_by(ppid_trialn) %>% # group by trials
  slice(1) %>% # slice the first value
  ungroup() %>%
  transmute(ppid_trialn, pNum, StartWorld_x = World_x, StartWorld_z = World_z, StartWorldYaw = WorldYaw) # save values

# obtain coordinates at first steering response for every trial 
threshcoords <- workingdata %>%
  group_by(ppid_trialn) %>%
  dplyr::filter(max(YawRateChange) > upperthreshold, min(YawRateChange) < lowerthreshold) %>% # filter lowest yaw rate change smaller than the lower theshold, # filter largest yaw rate change greater than the upper threshold
  slice(1:min(which(YawRateChange > upperthreshold, 1))) %>% # slice from the first yaw value, to the first yaw value above the upper thrshold
  slice(min(which(YawRateChange > lowerthreshold, 1))) %>% # slice the row at the minimum yaw rate above the lower threshold to get start of the response
  ungroup() %>%
  transmute(ppid_trialn, heading, ThreshWorld_x = World_x, ThreshWorld_z = World_z, ThreshWorldYaw = WorldYaw, ThreshYawRateChange = YawRateChange)


dat <- merge(trialstartcoords, threshcoords, by = "ppid_trialn")

```

Above code selects the world yaw value at the very beginning of the trial (i.e. the first frame that the line is visible). This is because at that this point the WorldYaw is already rotated for the offset.

```{r computing theta angle}

# radians conversion = (variable / 180 *pi)

dat <- dat %>%
  group_by(ppid_trialn) %>%
  mutate(ComputedHeading = StartWorldYaw) 

notproblem <- dat %>%
  filter(ComputedHeading < 315)

problem <- dat %>%
  filter(ComputedHeading >= 315) %>%
  mutate(ComputedHeading = 360 - ComputedHeading)

dat <- rbind(notproblem, problem)

dat <- dat %>%
  mutate(ComputedHeading = ComputedHeading - heading) %>%
  mutate(ComputedHeading_radians = ComputedHeading / 180 * pi) %>%
  mutate(ComputedErrorRate = 1 / (sin(ComputedHeading_radians) * 10))

```

Above code computes heading angle whilst accounting for carry over from the resetting of the steering wheel angle

To do this, I take the yaw at the start of the trial. I then take the absolute of this to get the computed heading angle in degrees and then subtract from this value the experiment heading manipulation. Hence the difference between these values should generate the heading angle that was observed by the subject.

WorldYaw is measured in degrees. Sometimes there are very high WordYaw values (near 360 degrees). I assume this is because the yaw has almost reached a full circle. For example, 358 degrees of WorldYaw might indicate a 2 degree heading angle to the right whereas a 2 degree WorldYaw might indicate a 2 degree heading angle to the left. This is fine, however it appears that I might have a heading angle of 358 when it is actually 2 degrees. Hence to account for this, I subtract the value from 360 in order account for this and collaspse across conditions.

```{r investigating computed heading}

View(dat %>% 
  group_by(pNum, heading) %>%
  summarise(meancomputedheading = mean(ComputedHeading)))

```

The computed heading angles still make little sense. 

Some of the computed headings do make sense, and match the experimental manipulation.

Some of the computed headings are negative (i.e. the percieved heading angle was in the oppsite direction to the experimental manipulation?

Some are vastly higher than the experimental manipulation (up to 20 degrees of heading offset).

All in all, nothing makes any sense whatsoever.

```{r the effect of steering wheel reset on the timecourse data}

setwd("C:/Users/pscmgo/OneDrive for Business/PhD/Project/Experiment_Code/Straights/Full_Data") 
temp = list.files(pattern = c("BenLui17_")) # list all CSV files in the directory
myfiles = lapply(temp, read.csv) # read these CSV in the directory
timecoursedata <- do.call(rbind.data.frame, myfiles) 

timecoursedata <- unite(timecoursedata, ppid_trialn, ppid, trialn, sep = "_") # create unique ppid_trialn ID

timecoursedata <- timecoursedata %>% 
  group_by(ppid_trialn) %>% 
  mutate(timestamp_zero = timestamp - timestamp[1],
         SWA_mirrored = SWA * sign(heading + 1e-6),
         abs_heading = abs(heading),
         diff_YR = c(0, diff(YawRate_seconds)))

ggplot(dplyr::filter(timecoursedata, abs_heading == 0.5), aes(x = timestamp_zero, y = SWA, group = ppid_trialn, col = ppid_trialn)) +
  geom_line() + 
  guides(colour = FALSE) +
  facet_wrap(~ pNum) +
  ggtitle("plotting SWA across multiple timecourses for each participant")

ggplot(dplyr::filter(timecoursedata, ppid_trialn == "1_3_88"), aes(x = timestamp_zero, y = WorldYaw)) +
  geom_line() + 
  guides(colour = FALSE) +
  ggtitle("plotting WorldYaw across timecourses")


```

The first plot shows the moment that the steering wheel angle is reset before the visible line is presented (at around 2 seconds). If subjects are moving the wheel just before or during the reset and then move it back just after, their trajectory will change and thus subjects will respond by correcting for this. This is what is meant by the "reset" carry over. 

There should be a straight line inbetween the first part of the trial before the reset and the second part of the trial after the reset. For a lot of subjects this is the case however a few seem to have heavy carry over from the reset (subject 1, 2, 16 for example).

Potentially, carry over for some subjects leads to higher over computed heading angles then what was experimentally manipulated. However this still doesn't explain why my computed angles of are not the same magnitude as the experimentally manipulated ones i.e. 2 degrees of heading angle is repeatedly the smallest computed angle. 

```{r computing hypotenuse}

dat <- dat %>%
  group_by(ppid_trialn) %>%
  mutate(a = (ThreshWorld_x - StartWorld_x)^2 + (ThreshWorld_z - StartWorld_z)^2) %>%
  mutate(hypo = sqrt(a))

```

Above code computes the hypotenuse i.e. the longest side of a triangle (trajectory of the offset heading). This is computed by subtracting the starting position X and Z coordinates from the position X and Z coordinates when the first steering response is made, squaring the result and adding them to values together. The square root is then taken.


```{r computing lane position/threshold}

dat <- dat %>%
  mutate(lane_position = sin(ComputedHeading) * hypo) 

```

Finally, you take the sine of the computed heading and multiple by the hypotenuse to calculate the lane position in metres.


```{r comparing threshold model lane position values to data}

# average threshold value for each error rate value according to constructed threshold model
modellingdata %>%
  group_by(heading) %>%
  summarise(meanLanePosition = mean(model_threshold))

# average threshold value for each error rate value according to data
dat %>%
  group_by(heading) %>%
  summarise(meanLanePosition = mean(lane_position))

```


