---
title: "lane_position"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load libraries}

library(dplyr)
library(tidyr)
library(ggplot2)

```

```{r load in full datasets}
# rm(list = ls())

# set working directory on office laptop

# unprocessed datasets 
# set working directory on personal laptop
# setwd("C:/Users/Courtney/Documents/PhD/Project/Experiment_code/Straights/Full_Data")
setwd("C:/Users/pscmgo/OneDrive for Business/PhD/Project/Experiment_Code/Straights/Full_Data") 
temp = list.files(pattern = c("BenLui17_")) # list all CSV files in the directory
myfiles = lapply(temp, read.csv) # read these CSV in the directory
workingdata <- do.call(rbind.data.frame, myfiles) # convert and combine the CSV files into dataframe

# pre-processed datasets
# set working directory on personal laptop
# setwd("C:/Users/Courtney/Documents/PhD/Project/Experiment_code/Straights")
setwd("C:/Users/pscmgo/OneDrive for Business/PhD/Project/Experiment_Code/Straights")
temp = list.files(pattern = c("magnitudedata", "*.csv")) # list all CSV files in the directory
myfiles = lapply(temp, read.csv) # read these CSV in the directory
magnitudedata <- do.call(rbind.data.frame, myfiles) # convert and combine the CSV files into dataframe


```

I need the raw datasets to obtain starting and ending WorldYaw values, and I need the pre-processed data to make a "true responses" tag so that I'm only calculating lane positions for valid trials. 

```{r creating unique ID tag, selecting only when line is visible and differentiate yaw rate}

upperthreshold = 0.13
lowerthreshold = 0.05

workingdata <- unite(workingdata, ppid_trialn, ppid, trialn, sep = "_") # create unique ppid_trialn ID

workingdata$StraightVisible <- as.numeric(workingdata$StraightVisible) # changes factor to numeric, 1 = false, 2 = true

# filter data for only period of the trial where line is visible
workingdata <- workingdata %>%
  group_by(ppid_trialn) %>%
  dplyr::filter(StraightVisible == 2) %>% # filter for only data where central line is visible
  dplyr::mutate(frame = row_number()) # create frame number column

# differentiate yaw rate metric
workingdata <- workingdata %>%
  mutate(YawRateChange = YawRate_seconds - c(0, YawRate_seconds[-length(YawRate_seconds)])) %>% # difference in yaw rate
  group_by(ppid_trialn) %>%
  dplyr::mutate(frame = row_number()) %>%
  ungroup()

# compute 2.5 second anchored timestamp
workingdata <- workingdata %>%
  group_by(ppid_trialn) %>%
  dplyr::mutate(anchored_timestamp = timestamp - min(timestamp)) %>%
  dplyr::filter(anchored_timestamp <= min(anchored_timestamp) + 2.5) %>% # add for seconds fro the original data 
  ungroup() 

```


```{r collapsing across heading values}

workingdata <- workingdata %>%
  group_by(ppid_trialn) %>%
  mutate(YawRateChange = YawRateChange * sign(heading + 1e-6)) %>% 
  mutate(World_x = World_x * sign(heading + 1e-6)) %>% 
  mutate(heading = abs(heading))
  
```

Collapsing across heading conditions

```{r selecting start thresh world yaw values}

# obtains starting coordinates for every trial
trialstartcoords <- workingdata %>%
  group_by(ppid_trialn) %>% # group by trials
  slice(1) %>% # slice the first value
  ungroup() %>%
  transmute(ppid_trialn, pNum, heading, StartWorld_x = World_x, StartWorld_z = World_z, StartWorldYaw = WorldYaw) # save values

# obtains ending coordinates for every trial
trialendcoords <- workingdata %>%
  group_by(ppid_trialn) %>%
  slice(n()) %>%
  ungroup %>%
  transmute(EndWorld_x = World_x, EndWorld_z = World_z, EndWorldYaw = WorldYaw) # save values

dat <- cbind(trialstartcoords, trialendcoords)

trueresponses <- magnitudedata$ppid_trialn # selects ID tags of true responses
trueresponses <- as.vector(trueresponses) # creates ID vector for filtering 

# filters starting and ending coordinates so only valid trials are selected
dat <- dplyr::filter(dat, ppid_trialn %in% trueresponses) # filter the IDs in the ID vector

# obtains coordinates at the moment the first steering response was triggered
threshcoords <- workingdata %>% 
  group_by(ppid_trialn) %>%
  dplyr::filter(max(YawRateChange) > upperthreshold, min(YawRateChange) < lowerthreshold) %>% # filter lowest yaw rate change smaller than the lower theshold, # filter largest yaw rate change greater than the upper threshold
  slice(1:min(which(YawRateChange > upperthreshold, 1))) %>% # slice from the first yaw value, to the first yaw value above the upper thrshold
  slice(min(which(YawRateChange > lowerthreshold, 1))) %>% # slice the row at the minimum yaw rate above the lower threshold to get start of the response
  ungroup() %>%
  transmute(ppid_trialn, heading, ThreshWorldYaw = WorldYaw, ThreshWorld_x = World_x, ThreshWorld_z = World_z)

# filters threshold coordinates so only valid trials are selected
threshcoords <- dplyr::filter(threshcoords, ppid_trialn %in% trueresponses)
threshcoords$ppid_trialn <- NULL
threshcoords$heading <- NULL

dat <- cbind(dat, threshcoords)

```

Above code selects the world yaw value at the very beginning of the trial (i.e. the first frame that the line is visible) and the WorldYaw value at the end of the trial (line is still visible but the subject has completed their turn of the angle they have observed). 

The above code also selects world_x and world_z coordinates at the start of the trial and at the moment of the firsts steering response. This is done in order to calculate hypotenuse for formulating lane position.

```{r computing theta angle}

# radians conversion = (variable / 180 *pi)

dat <- dat %>%
  group_by(ppid_trialn) %>%
  mutate(ComputedHeading = abs(EndWorldYaw - StartWorldYaw)) 

notproblem <- dat %>%
  dplyr::filter(ComputedHeading < 315)

problem <- dat %>%
  dplyr::filter(ComputedHeading >= 315) %>%
  mutate(ComputedHeading = 360 - ComputedHeading)

dat <- rbind(notproblem, problem)

dat <- dat %>%
  mutate(ComputedHeading_radians = ComputedHeading / 180 * pi) %>%
  mutate(ComputedErrorRate = 1 / (sin(ComputedHeading_radians) * 10))

```

Above code computes heading angle whilst accounting for carry over from the resetting of the steering wheel angle

To do this, I take the yaw at the start of the trial and subtract it from the yaw at the end of the trial and take the absolute of this value. This calculates the heading angle that subjects have accounted for during the trial, and thus takes into account any carryover from the steering wheel reset.

WorldYaw is measured in degrees. Sometimes there are very high WordYaw values (near 360 degrees). I assume this is because the yaw has almost reached a full circle (360 degrees). For example, 358 degrees of WorldYaw might indicate a 2 degree heading angle to the left whereas a 2 degree WorldYaw might indicate a 2 degree heading angle to the right. This is fine, however it appears that I might have a heading angle of 358 when it is actually 2 degrees. Hence to account for this, I subtract the value from 360 in order account for this and collaspse across conditions.

```{r investigating computed heading}

View(dat %>% 
  group_by(heading) %>%
  summarise(meancomputedheading = mean(ComputedHeading)) %>%
    mutate(heading_diff = meancomputedheading - heading))

```

The computed heading angles now makes a lot more sense. None of them are perfect, with some suffering from steering wheel reset carry over. However, they make a lot more sense than before. 

This also demonstrates why some subjects were reacting in the apparent "0 heading" condition. The computed heading angles demonstrate that possibly due to carry over in some trials, there might always be a slight heading angle even for the 0 heading conditions, thus people are steering to correct for this formulated angle. 

```{r computing hypotenuse}

dat <- dat %>%
  group_by(ppid_trialn) %>%
  mutate(a = (ThreshWorld_x - StartWorld_x)^2 + (ThreshWorld_z - StartWorld_z)^2) %>%
  mutate(hypo = sqrt(a))

```

Above code computes the hypotenuse i.e. the longest side of a triangle (trajectory of the offset heading). This is computed by subtracting the starting position X and Z coordinates from the position X and Z coordinates when the first steering response is made, squaring the result and adding them to values together. The square root is then taken.

Using these coordinates means measuring the distance travelled from the moment the line appears, to the moement that the trajectory starts to change (i.e. when the first steering response is triggered).

```{r computing lane position/threshold}

dat <- dat %>%
  mutate(lane_position = sin(ComputedHeading_radians) * hypo) 

```

Finally, you take the sine of the computed heading and multiple by the hypotenuse to calculate the lane position in metres. Make sure that you're taking the sine of the computed heading in radians.

```{r computing lateral position error and visualsing}

# average threshold value for each error rate value according to data
dat_latpos <- dat %>%
  dplyr::filter(heading > 0) %>%
  group_by(heading) %>%
  summarise(data = mean(lane_position)) %>%
  gather(key = "modeltype", value = "latpos", data)

# original bar plots for lateral position error
ggplot(dat %>%
         dplyr::filter(heading > 0) %>%
         group_by(heading) %>%
         summarise(meanLateralPositionDATA = mean(lane_position)), aes(x = heading, y = meanLateralPositionDATA)) +
  geom_bar(colour = "black", stat = "identity") +
  theme_gray() +
  guides(fill = FALSE) +
  xlab("Heading (degrees)") +
  ylab("Lateral position from line (m)") +
  ylim(0, 0.2) +
  theme(axis.title.x = element_text(size = 16), axis.text.x = element_text(size = 16), axis.title.y = element_text(size = 17), axis.text.y = element_text(size = 16), title = element_text(size = 16), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black")) +
  ggtitle("Lateral position from the road-line at steering onset") +
  ggsave('latpos.png', plot = last_plot(), width = 22, height = 13, units = 'cm', dpi = 300, type = 'cairo')

# bar plots with 95 CIs erro bars to show variability of lateral position erro across condition

latpos <- dat %>%
  select(heading, lane_position)

latpos <- summarySE(latpos, measurevar = "lane_position", groupvars = c("heading"))

ggplot(latpos, aes(x = heading, y = lane_position)) + 
    geom_bar(colour = "black", stat = "identity") +
    geom_errorbar(aes(ymin = lane_position - se, ymax = lane_position + se), width = .1) +
    geom_point() +
    guides(fill = FALSE) +
  xlab("Heading (degrees)") +
  ylab("Lateral position from line (m)") +
  ylim(0, 0.2) +
  theme(axis.title.x = element_text(size = 16), axis.text.x = element_text(size = 16), axis.title.y = element_text(size = 17), axis.text.y = element_text(size = 16), title = element_text(size = 16), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black")) +
  ggtitle("Lateral position from the road-line at steering onset") +
  ggsave('latpos.png', plot = last_plot(), width = 22, height = 13, units = 'cm', dpi = 300, type = 'cairo')

```
Threshold model predicts very similar lane position thresholds across conditions. This would possibly be expected under the threshold model as it proposes a fixed threhsold across conditions. Once the threshold has been surpassed, a response is initiated. The RTs may differ (i.e. it may take longer to reach the threshold value if error growth is very slow) however the ultimate fixed threshold is still likely to be the same.

One thing to take into account for the threshold model is that intercepts (latencies) for some subjects was slower than some of the trial  RTs for that participant... suggests that the model might not be good at predicting that. Thus when I then going to calculate the overall threshold model, the triggered response time is negative i.e. subjects know when to respond before they have even processed the visual information...

In contrast, the collected data proposes that there are different threshold values for increased heading. More specifically, for increased heading values the mean lane position also increases. Intuitively, this might make sense for the accumulator as this model predicts that subjects will respond to to lower absolute errors when there is more time over which to intergrate the evidence. 

**ggsave**

ggsave allows for better figure saving. Get size of the figure you want from powerpoint and then input dimensions into the function so they are not too distorted when resizing in your powerpoint.

```{r load data}

# full raw datasets
setwd("C:/Users/pscmgo/OneDrive for Business/PhD/Project/Experiment_Code/Straights/Full_Data") 
# setwd("C:/Users/Courtney/Documents/PhD/Project/Experiment_code/Straights/Full_Data")
temp = list.files(pattern = c("BenLui17_")) # list all CSV files in the directory
myfiles = lapply(temp, read.csv) # read these CSV in the directory
timecoursedata <- do.call(rbind.data.frame, myfiles) 

# pre-processed datasets
# set working directory on personal laptop
# setwd("C:/Users/Courtney/Documents/PhD/Project/Experiment_code/Straights")
setwd("C:/Users/pscmgo/OneDrive for Business/PhD/Project/Experiment_Code/Straights")
temp = list.files(pattern = c("magnitudedata", "*.csv")) # list all CSV files in the directory
myfiles = lapply(temp, read.csv) # read these CSV in the directory
magnitudedata <- do.call(rbind.data.frame, myfiles) # convert and combine the CSV files into dataframe

timecoursedata <- tidyr::unite(timecoursedata, ppid_trialn, ppid, trialn, sep = "_") # create unique ppid_trialn ID

trueresponses <- magnitudedata$ppid_trialn # selects ID tags of true responses
trueresponses <- as.vector(trueresponses) # creates ID vector for filtering

timecoursedata <- dplyr::filter(timecoursedata, ppid_trialn %in% trueresponses)

```


```{r mirroring position coords and yaw rate values}

timecoursedata <- timecoursedata %>% 
  group_by(ppid_trialn) %>% 
  mutate(timestamp_zero = timestamp - timestamp[1], 
         SWA_mirrored = SWA * sign(heading + 1e-6),
         WorldYaw = WorldYaw * sign(heading + 1e-6),
         World_x = World_x * sign(heading + 1e-6),
         diff_YR = c(0, diff(YawRate_seconds)),
         diff_YR_mirrored = diff_YR * sign(heading + 1e-6),
         heading = abs(heading),
         frame = row_number()) %>%
  mutate(diff_YR_mirrored = sgolayfilt(diff_YR_mirrored, n = 11)) # golay filter data
  
```

```{r computing steering bias}
# example dataframe for stack overflow
# dput(head(modellingdata, n = 5))

timecoursedata <- timecoursedata %>%
  group_by(ppid_trialn) %>%
  mutate(diff_WorldYaw = c(0, diff(WorldYaw))) %>% # diff in world yaw between frames 
  mutate(diff_hypotenuse = sqrt((c(0, diff(World_x))^2 + c(0, diff(World_z))^2))) %>% # diff in hypotenuse between frames
  mutate(lane_deviation = sin(diff_WorldYaw) * diff_hypotenuse) %>% # difference in lane position between frames
  mutate(steeringbias = cumsum(lane_deviation)) # cumulative total of lane deviation across trials

ggplot(data = dplyr::filter(timecoursedata, ppid_trialn == "6_2_4"), aes(x = timestamp_zero, y = steeringbias)) +
  geom_point()

```