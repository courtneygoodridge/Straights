---
title: "diffusion model"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r strength of signal effect on output}
library(dplyr)
library(lattice)

agg_RT <- magnitudedata %>%
  group_by(heading) %>% 
  summarise(prop = mean(PeakYaw), mean_rt = mean(FirstSteeringTime), median_rt = median(FirstSteeringTime)) %>% 
  ungroup()

xyplot(prop ~ heading, agg_RT, type = "b", auto.key = list(lines = TRUE))

```

Effect of strength of the error signal on the proportion of the response (peak yaw). In example, strengh th refers to brightness of pixels but in mine, strength refers to heading (increased rate of change in error)

```{r quantiles}
library(dplyr)
library(lattice)

quantiles_RT <- magnitudedata %>%
  group_by(heading) %>%
  nest() %>%
  mutate(quantiles = map(data, ~ as.data.frame(t(quantile(.x$FirstSteeringTime, probs = quantiles))))) %>% 
  unnest(quantiles) %>%
  gather("quantile", "rt",`10%`:`90%`) %>% 
  arrange(heading)

xyplot(rt ~ heading, quantiles_RT, group = quantile, type = "b", 
       auto.key = list(lines = TRUE), ylab = "RT (in seconds)")

```

Appears to show a larger effect of strength for higher quantiles i.e. the slower of the responses.

```{r diffusion model analysis}
library(dplyr)

# This creates a nested dataframe, where each ppid_trialn has column containing all of it's data  

d_nested <- magnitudedata %>% 
  group_by(ppid_trialn) %>%
  nest()
View(d_nested) 

```

```{r diffusion wrapper function}

objective_diffusion_separate <- function(pars, rt, drift, ...) {
  non_v_pars <- grep("^v", names(pars), invert = TRUE, value = TRUE)
  base_par <- length(non_v_pars)  # number of non-drift parameters
  densities <- vector("numeric", length(rt))
  for (i in seq_along(levels(drift))) {
    densities[drift == levels(drift)[i]] <- 
      ddiffusion(rt[drift == levels(drift)[i]], 
                 a=pars["a"], t0=pars["t0"],  
                 sv=pars["sv"],
                 sz=if ("sz" %in% non_v_pars) pars["sz"] else 0.1,
                 z=if ("z" %in% non_v_pars) pars["z"]*pars["a"] else 0.5*pars["a"],
                 st0=if ("st0" %in% non_v_pars) pars["st0"] else 0, 
                 v=pars[base_par+i])
  }
  if (any(densities == 0)) return(1e6)
  return(-sum(log(densities)))
}

# function that creates random start values, also 
get_start <- function(base_par, n_drift = 5) {
  start1 <- c(
    a = runif(1, 0.5, 3),
    a_1 = runif(1, 0.5, 3), 
    a_2 = runif(1, 0.5, 3),
    t0 = runif(1, 0, 0.5), 
    z = runif(1, 0.4, 0.6), 
    sz = runif(1, 0, 0.5),
    sv = runif(1, 0, 0.5),
    st0 = runif(1, 0, 0.5),
    d = rnorm(1, 0, 0.05)
  )
  start2 <- sort(rnorm(n_drift), decreasing = FALSE)
  names(start2) <- paste0("v_", seq_len(n_drift))
  c(start1[base_par], start2)
}



# function that tries different random start values until it works:
ensure_fit <- 
  function(data, start_function, objective_function, 
           base_pars, n_drift = 5, n_fits = 1, 
           lower = c(rep(0, length(base_pars)), -Inf,
                     rep(-Inf,length(start_function(base_pars))-length(base_pars)))) {
    best_fit <- list(objective = 1e+06)
  for (i in seq_len(n_fits)) {
    start_ll <- 1e+06
    #browser()
    while(start_ll == 1e+06) {
      start <- start_function(base_pars, n_drift=n_drift)
      start_ll <- objective_function(start, 
                                     rt = data$rt, 
                                     drift = factor(data$strength_bin, seq_len(n_drift)), 
                                     instruction = data$instruction)
    }
    cat("\nstart fitting.\n") # just for information to see if it is stuck

    fit <- nlminb(start, objective_function, 
                  rt = data$rt, 
                  drift = factor(data$strength_bin, seq_len(n_drift)), 
                  instruction = data$instruction,
                  lower = lower)

    if (fit$objective < best_fit$objective) best_fit <- fit
  }
  out <- as.data.frame(t(unlist(best_fit[1:3])))
  colnames(out) <- sub("par.", "", colnames(out))
  out
}

```

```{r loop over participants and items to obtain the fit}
library(purrr)
library(dplyr)

fit_diffusion <- d_nested %>% 
  mutate(fit = 
           map(data, 
               ~ensure_fit(data = ., start_function = get_start, 
                            objective_function = objective_diffusion_separate, 
                            base_pars = c("a", "t0", "sv", "sz", "z")))) %>% 
  unnest(fit)

* CHANGE STRENGTH_BIN TO HEADING *

```
