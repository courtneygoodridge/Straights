---
title: "lane_position"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load libraries}

library(dplyr)
library(tidyr)
library(ggplot2)

```

```{r load in full datasets}
# rm(list = ls()) 
# full datasets
# set working directory on office laptop
setwd("C:/Users/pscmgo/OneDrive for Business/PhD/Project/Experiment_Code/Straights/Full_Data") 

# working directory for personal laptop
# setwd("C:/Users/Courtney/Documents/PhD/Project/Experiment_code/Straights/Full_Data")

temp = list.files(pattern = c("BenLui17_")) # list all CSV files in the directory
myfiles = lapply(temp, read.csv) # read these CSV in the directory
workingdata <- do.call(rbind.data.frame, myfiles) # convert and combine the CSV files into dataframe

```


```{r computing triggered time and threshold (in metres)}

modellingdata <- modellingdata %>%
  group_by(pNum) %>%
  mutate(triggered_time = FirstSteeringTime - individual_intercept) %>%
  mutate(model_threshold = triggered_time / error_rate)

```

Subtracting the intercept value (latency) from the RT generates the triggered response time i.e. how long before subjects realised they needed to make a response. Firstly some of these values are negative, suggested that the model is predicting latency values that are longer than what people are actually responding... on a qualitative level, this could indicate the model does not describe the data well...

Callum proposes that to generate threshold from the model, I can divide triggered time by error rate. However this does not make sense to me. If error rate is considered speed, triggered time is considered time, and threshold considered distance, then speed / time does not equal a distance according to the distance/speed/time triangle. When do this I also get very strange numbers...

It makes more sense to me that triggered_time (time) * error_rate (speed) = threshold (distance)

**check with Callum**

```{r create unique ID tag and differentiate yaw rate}

upperthreshold = 0.13
lowerthreshold = 0.05

workingdata <- unite(workingdata, ppid_trialn, ppid, trialn, sep = "_") # create unique ppid_trialn ID

workingdata <- workingdata %>%
  mutate(YawRateChange = YawRate_seconds - c(0, YawRate_seconds[-length(YawRate_seconds)])) %>% # difference in yaw rate
  group_by(ppid_trialn) %>%
  mutate(frame = row_number()) %>%
  ungroup()

```

```{r collapsing across heading values}

negativetimecourse <- workingdata %>%
  dplyr::filter(heading < 0) %>%
  mutate(heading = abs(heading)) %>%
  mutate(YawRateChange = abs(YawRateChange))

positivetimecourse <- workingdata %>%
  dplyr::filter(heading > 0) %>%
  mutate(heading = abs(heading)) %>%
  mutate(YawRateChange = YawRateChange)
  
zerotimecourse <- workingdata %>%
  dplyr::filter(heading == 0) %>%
  mutate(heading = abs(heading)) 

workingdata <- rbind(negativetimecourse, positivetimecourse, zerotimecourse)

rm(negativetimecourse, positivetimecourse, zerotimecourse)


```


```{r selecting start thresh world yaw values}

# obtains starting coordinates for every trial
trialstartcoords <- workingdata %>%
  group_by(ppid_trialn) %>% # group by trials
  slice(1) %>% # slice the first value
  ungroup() %>%
  transmute(ppid_trialn, StartWorld_x = World_x, StartWorld_z = World_z, StartWorldYaw = WorldYaw) # save values

# obtain coordinates at first steering response for every trial 
threshcoords <- workingdata %>%
  group_by(ppid_trialn) %>%
  dplyr::filter(max(YawRateChange) > upperthreshold, min(YawRateChange) < lowerthreshold) %>% # filter lowest yaw rate change smaller than the lower theshold, # filter largest yaw rate change greater than the upper threshold
  slice(1:min(which(YawRateChange > upperthreshold, 1))) %>% # slice from the first yaw value, to the first yaw value above the upper thrshold
  slice(min(which(YawRateChange > lowerthreshold, 1))) %>% # slice the row at the minimum yaw rate above the lower threshold to get start of the response
  ungroup() %>%
  transmute(ppid_trialn, heading, ThreshWorld_x = World_x, ThreshWorld_z = World_z, ThreshWorldYaw = WorldYaw, ThreshYawRateChange = YawRateChange)


dat_start_thresh <- merge(trialstartcoords, threshcoords, by = "ppid_trialn")

```

Above code selects the world yaw value at the very beginning of the trial (i.e. when the line is not visible) and at the moment of the first steering response.

```{r selecting start and end world yaw values with only values that make threshold}

trueresponses <- threshcoords$ppid_trialn # selects ID tags of true responses
trueresponses <- as.vector(trueresponses) # creates ID vector for filtering 

trialstartcoords <- dplyr::filter(trialstartcoords, ppid_trialn %in% trueresponses)

# obtains ending coordinates for every trial
trialendcoords <- workingdata %>%
  group_by(ppid_trialn) %>% # group by trials
  slice(n()) %>% # slice last values
  ungroup() %>%
  transmute(ppid_trialn, heading, EndWorld_x = World_x, EndWorld_z = World_z, EndWorldYaw = WorldYaw) # save values

trialendcoords <- dplyr::filter(trialendcoords, ppid_trialn %in% trueresponses)

trialendcoords$ppid_trialn <- NULL


dat_start_end <- cbind(trialstartcoords, trialendcoords)

```

```{r selecting start and peakworlf yaw values}

dat_start_peak <- modellingdata %>%
  dplyr::select(ppid_trialn, heading, PeakWorldYaw, PeakWorld_x, PeakWorld_z)

dat_start_peak <- merge(dat_start_peak, trialstartcoords, by = "ppid_trialn")

rm(trialstartcoords, threshcoords, trialendcoords)

```


```{r computing theta angle}


dat_start_end <- dat_start_end %>%
  group_by(ppid_trialn) %>%
  mutate(ComputedHeading = EndWorldYaw - StartWorldYaw) %>%
  mutate(ComputedHeading = abs(ComputedHeading)) %>%
  mutate(ComputedHeading_radians = ComputedHeading / 180 * pi) %>%
  mutate(ComputedErrorRate = 1 / (sin(ComputedHeading_radians) * 10))
  
# radians conversion = (variable / 180 *pi)

dat_start_thresh <- dat_start_thresh %>%
  group_by(ppid_trialn) %>%
  mutate(ComputedHeading = ThreshWorldYaw - StartWorldYaw) %>%
  mutate(ComputedHeading = abs(ComputedHeading)) %>%
  mutate(ComputedHeading_radians = ComputedHeading / 180 * pi) %>%
  mutate(ComputedErrorRate = 1 / (sin(ComputedHeading_radians) * 10))

dat_start_peak <- dat_start_peak %>%
  group_by(ppid_trialn) %>%
  mutate(ComputedHeading = PeakWorldYaw - StartWorldYaw) %>%
  mutate(ComputedHeading = abs(ComputedHeading)) %>%
  mutate(ComputedHeading_radians = ComputedHeading / 180 * pi) %>%
  mutate(ComputedErrorRate = 1 / (sin(ComputedHeading_radians) * 10))

```

Above code computes heading angle whilst accounting for carry over from the resetting of the steering wheel angle

To do this, I take the yaw when the response was triggered, and subtract from it the yaw at the beginning of trial. I then take the abosolute of this to get the computed heading angle in degrees.

```{r computing angle for WorldYaw that is near 360 degrees}

notproblem <- dat_start_end %>%
  filter(ComputedHeading < 350)

problem <- dat_start_end %>%
  filter(ComputedHeading >= 350) %>%
  mutate(ComputedHeading = 360 - ComputedHeading)

dat_start_end <- rbind(notproblem, problem)

rm(notproblem, problem)

notproblem <- dat_start_thresh %>%
  filter(ComputedHeading < 350)

problem <- dat_start_thresh %>%
  filter(ComputedHeading >= 350) %>%
  mutate(ComputedHeading = 360 - ComputedHeading)

dat_start_thresh <- rbind(notproblem, problem)

rm(notproblem, problem)

notproblem <- dat_start_peak %>%
  dplyr::filter(ComputedHeading < 350)

problem <- dat_start_peak %>%
  dplyr::filter(ComputedHeading >= 350) %>%
  mutate(ComputedHeading = 360 - ComputedHeading)

dat_start_peak <- rbind(notproblem, problem)

rm(notproblem, problem)


```

WorldYaw is measured in degrees. Thus when there is a high world yaw (near 360 degrees) minus a small one at the start, it creates a problems... converting to radians does not solve this problem.

However if take the values that are near 360 degrees, subtract 360 degrees from them and then perform the calculation, this solves the problem.

```{r investigating conmputed heading}

dat_start_thresh %>%
  group_by(heading) %>%
  summarise(meancomputedheading = mean(ComputedHeading))

dat_start_end %>%
  group_by(heading) %>%
  summarise(meancomputedheading = mean(ComputedHeading))

dat_start_peak %>%
  group_by(heading) %>%
  summarise(meancomuptedheading = mean(ComputedHeading))

```

When computing the heading values that people react to using the start WorldYaw and the WolrdYaw at response triggered, I get computed heading values that do not make sense. Even if this were true, how come people are observing near identical heading angles bu still have differences in RT?

If I compute heading values using start WorldYaw and WorldYaw at the end of the trial, I get much more sensible heading values...

I think this is because of how the experiment is set up. The road is offset relative to the driver, rather than the driver being offset relative the road. Thus if you take the WorldYaw at the trial beginning, and WorldYaw when subjects first respond, there is likely to be very little difference because they technicially haven't moved much at all in the yaw direction.

Conversely, if I take the WorldYaw at the start of the trial and the WorldYaw at the peak of steering response, I will be able to generate a more accurate value for the computed heading. When I compute this, I find that computed heading angles are not perfect, but make a bit more sense than using WorldYaw start and WorldYaw at first response **check with Callum**

```{r computing hypotenuse}

dat_start_end <- dat_start_end %>%
  group_by(ppid_trialn) %>%
  mutate(a = (EndWorld_x - StartWorld_x)^2 + (EndWorld_z - StartWorld_z)^2) %>%
  mutate(hypo = sqrt(a))

dat_start_thresh <- dat_start_thresh %>%
  group_by(ppid_trialn) %>%
  mutate(a = (ThreshWorld_x - StartWorld_x)^2 + (ThreshWorld_z - StartWorld_z)^2) %>%
  mutate(hypo = sqrt(a))

dat_start_peak <- dat_start_peak %>%
  group_by(ppid_trialn) %>%
  mutate(a = (PeakWorld_x - StartWorld_x)^2 + (PeakWorld_z - StartWorld_z)^2) %>%
  mutate(hypo = sqrt(a))

```

Above code computes the hypotenuse i.e. the longest side of a triangle (trajectory of the offset heading). This is computed by subtracting the starting position X and Z coordinates from the end position X and Z coordinates, squaring the result and adding them to values together. The square root is then taken.


```{r computing lane position/threshold}

dat_start_end <- dat_start_end %>%
  mutate(lane_position = sin(ComputedHeading) * hypo) 

dat_start_thresh <- dat_start_thresh %>%
  mutate(lane_position = sin(ComputedHeading) * hypo) 

dat_start_peak <- dat_start_peak %>%
  mutate(lane_position = sin(ComputedHeading) *hypo)

```

Finally, you take the sine of the computed heading and multiple by the hypotenuse to calculate the lane position in metres.

Currently, this is calculating the lane position from the very start of the trial (when the line is not visible) to when the response was triggerd i.e when the RT value is obtained.

```{r comparing threshold model lane position values to data}

# average threshold value for each error rate value according to constructed threshold model
modellingdata %>%
  filter(model_threshold > 0) %>%
  filter(data_lane_position > 0) %>%
  group_by(heading) %>%
  summarise(meanLanePosition = mean(data_lane_position), meanlaneprediction = mean(model_threshold))

# average threshold value for each error rate value according to data
dat_start_peak %>%
  group_by(heading) %>%
  summarise(meanLanePosition = mean(lane_position))

dat_start_thresh %>%
  group_by(heading) %>%
  summarise(meanLanePosition = mean(lane_position))

dat_start_end %>%
  group_by(heading) %>%
  summarise(meanLanePosition = mean(lane_position))

```


