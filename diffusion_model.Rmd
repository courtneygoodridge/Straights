---
title: "diffusion model"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r strength of signal effect on output}
library(dplyr)
library(lattice)

# select variables from main data set

example <- magnitudedata %>%
  select(pNum, heading, FirstSteeringTime)

# create one choice response variables

example <- example %>%
  group_by(pNum) %>%
  mutate(response = "steer", response_num = 1)

agg_RT <- magnitudedata %>%
  group_by(heading) %>% 
  summarise(mean_rt = mean(FirstSteeringTime), median_rt = median(FirstSteeringTime)) %>% 
  ungroup()

xyplot(mean_rt ~ heading, agg_RT, type = "b", auto.key = list(lines = TRUE))

```

Effect of strength of the error signal on the proportion of the response (peak yaw). In example, strength refers to brightness of pixels but in my experiment, strength refers to heading (increased rate of change in error)

```{r quantiles}
library(dplyr)
library(lattice)
library(latticeExtra)
library(purrr)
library(rtdists)
library(binom)

quantiles <- c(0.1, 0.3, 0.5, 0.7, 0.9)

quantiles_RT <- magnitudedata %>%
  group_by(pNum, heading) %>%
  nest() %>%
  mutate(quantiles = map(data, ~ as.data.frame(t(quantile(.x$FirstSteeringTime, probs = quantiles))))) %>% 
  unnest(quantiles) %>%
  gather("quantile", "rt",`10%`:`90%`) %>% 
  arrange(heading)

xyplot(rt ~ heading|pNum, quantiles_RT, group = quantile, type = "b", 
       auto.key = list(lines = TRUE), ylab = "RT (in seconds)")

```

Appears to show a larger effect of strength for higher quantiles i.e. the slower of the responses.

```{r diffusion model analysis}
library(dplyr)

# This creates a nested dataframe, where each ppid_trialn has column containing all of it's data  

d_nested <- example %>% 
  group_by(pNum) %>% 
  nest() # nest the participants, not the trials
View(d_nested) 

```

```{r diffusion wrapper function}

# objective function for diffusion with 1 a. loops over drift to assign drift rates to strength
objective_diffusion_separate <- function(pars, rt, response, drift, ...) {
  non_v_pars <- grep("^v", names(pars), invert = TRUE, value = TRUE)
  base_par <- length(non_v_pars)  # number of non-drift parameters
  densities <- vector("numeric", length(rt))
  for (i in seq_along(levels(drift))) {
    densities[drift == levels(drift)[i]] <- 
      ddiffusion(rt[drift == levels(drift)[i]], response = "lower", 
                 a=pars["a"], t0=pars["t0"],  
                 sv=pars["sv"],
                 sz=if ("sz" %in% non_v_pars) pars["sz"] else 0.1,
                 z=if ("z" %in% non_v_pars) pars["z"]*pars["a"] else 0.5*pars["a"],
                 st0=if ("st0" %in% non_v_pars) pars["st0"] else 0, 
                 v=pars[base_par+i])
  }
  if (any(densities == 0)) return(1e6)
  return(-sum(log(densities)))
}


# function that creates random start values, also 
get_start <- function(base_par, n_drift = 5) {
  start1 <- c(
    a = runif(1, 0.5, 3),
    a_1 = runif(1, 0.5, 3), 
    a_2 = runif(1, 0.5, 3),
    t0 = runif(1, 0, 0.5), 
    z = runif(1, 0.4, 0.6), 
    sz = runif(1, 0, 0.5),
    sv = runif(1, 0, 0.5),
    st0 = runif(1, 0, 0.5),
    d = rnorm(1, 0, 0.05)
  )
  start2 <- sort(rnorm(n_drift), decreasing = FALSE)
  names(start2) <- paste0("v_", seq_len(n_drift))
  c(start1[base_par], start2)
}



# function that tries different random start values until it works:
ensure_fit <- 
  function(data, start_function, objective_function, 
           base_pars, n_drift = 5, n_fits = 1, 
           lower = c(rep(0, length(base_pars)), -Inf,
                     rep(-Inf,length(start_function(base_pars))-length(base_pars)))) {
    best_fit <- list(objective = 1e+06)
  for (i in seq_len(n_fits)) {
    start_ll <- 1e+06
    #browser()
    while(start_ll == 1e+06) {
      start <- start_function(base_pars, n_drift=n_drift)
      start_ll <- objective_function(start, 
                                     rt = example$FirstSteeringTime, response = example$response_num, 
                                     drift = factor(example$heading, seq_len(n_drift)))
    }
    cat("\nstart fitting.\n") # just for information to see if it is stuck

    fit <- nlminb(start, objective_function, 
                  rt = example$FirstSteeringTime, response = example$response_num, 
                  drift = factor(example$heading, seq_len(n_drift)),
                  lower = lower)

    if (fit$objective < best_fit$objective) best_fit <- fit
  }
  out <- as.data.frame(t(unlist(best_fit[1:3])))
  colnames(out) <- sub("par.", "", colnames(out))
  out
}

```

```{r loop over participants and items to obtain the fit}
library(purrr)
library(dplyr)

fit_diffusion <- d_nested %>% 
  mutate(fit = 
           map(data, 
               ~ensure_fit(data = ., start_function = get_start, 
                            objective_function = objective_diffusion_separate, 
                            base_pars = c("a", "t0", "sv", "sz", "z")))) %>% 
  unnest(fit)

```
